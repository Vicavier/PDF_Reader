### 第3章 共进化的主要方法：竞争与合作  
#### 3.1 共进化算法：简介  

在第2章中，我们使用了共进化系统作为一个广义的概念性术语，来指代共进化计算的各种实现形式。尽管许多研究已经在学习和优化问题等场景中使用这些共进化系统解决问题，但这些系统也能用于其他场景，比如模拟环境。为进一步说明这一点，可以考虑一类广义的非合作游戏，例如迭代囚徒困境（Iterated Prisoner’s Dilemma, IPD），该家族中的游戏同时具有竞争和合作元素$[1, 36]$。在此，共进化系统可以在以下两种设定中使用：

1. 用于评估搜索过程对博弈策略性能的表现，例如在共进化学习中使用共进化算法（Coevolutionary Algorithms, CEAs），当目标是专注于个体策略相对于其他单个策略的表现时（例如，“All Defect”成为占优纯策略）$[9, 10]$。  
2. 用于研究适应过程中的条件，这些条件通过共进化模拟引发特定种群行为，当解决方案的重点是整个种群作为一个整体的表现时（例如，演化为同时最大化所有共同进化的智能体收益的互惠合作）$[7]$。  

本章将聚焦于针对第一种问题解决场景的共进化系统相关内容，这种场景涉及寻求表现优越的解决方案的搜索过程。尤其是，我们将描述实现这些CEAs的关键实现细节以及采用的机制。为了更清晰地通过示例来展示这些竞争与合作共进化的算法细节，我们将选取两个问题解决场景——学习与优化——作为背景。在讨论这两个问题解决场景时，我们将重点关注由各共进化方法在搜索解空间环境中解决的问题挑战的核心方面。例如，对于用于两人棋盘游戏场景的竞争性共进化，解决的核心问题在于寻找最优的博弈策略，其解决方案表示形式采用参数化的棋盘状态评估函数，例如人工神经网络（Artificial Neural Networks, ANNs）。
这些刺激-响应或反射型代理本质上通过代理采用的参数化函数所生成的棋盘状态评估，执行单层搜索（single-ply search）[5, 8, 17, 18]。换句话说，游戏中需要生成合适的动作序列的推理复杂度在解决方案表示中已抽象化。这与经典人工智能（AI）通过游戏树搜索解决问题的方法有所不同，后者的目标是找到搜索树中的路径，可以生成两名玩家所有可能的轮流合法动作序列，并以胜局作为终止状态。其他更复杂的搜索问题包括基于知识的代理规划，这涉及根据其内在知识表示进行推理，用以设计计划或动作序列以应对环境中的问题[48]。在这些问题上，关于共进化（coevolution）的研究日益增多，其中包括演化机器人技术（Evolutionary Robotics）以及实时战略游戏（Real-Time Strategy）应用的相关研究[14, 20, 44]。在本章的其余部分，我们将更详细地描述和讨论用于问题解决的共进化算法（Coevolutionary Algorithms, CEAs）的这些实现及其机制。

第3.2节将基于生成与测试（generate-and-test）框架，围绕特定交互构建竞争性与合作性共进化算法的核心工作原理。我们将以这些竞争性和合作性框架为关键点展开讨论，以区分二者的差异。第3.3节将重点探讨在两部分中利用这些共进化方法进行问题解决的应用。第一部分将讨论用于学习问题的竞争性共进化算法（competitive CEAs），而第二部分将聚焦于用于优化问题的合作性共进化算法（cooperative CEAs）。本章最后将给出讨论和总结，阐述竞争性与合作性共进化方法如何结合以解决具有挑战性的问题。

**3.2 共进化算法的框架**

本节将介绍两种共进化方法的一般框架。我们首先在第3.2.1节介绍竞争性共进化算法的框架，然后在第3.2.2节介绍合作性共进化算法的框架。这些框架是基于先前在第1.2章介绍的一般生成与测试框架（见算法1.1）的扩展版本。可以将这些框架视为特定扩展，包含了代理交互的基本机制，从而使得特定共进化搜索方法成为可能。这些机制包括竞争性共进化中的对抗交互（adversarial interactions）以及合作性共进化中的基于"分而治之"（Divide-and-Conquer）策略的交互。

**3.2.1 竞争性共进化**
竞争性协同进化（竞争性CEA）的通用框架描述在算法3.1中。需要注意的是，在呈现该框架时，我们考虑了一个更一般化的设置，其中协同进化中代理之间的对抗性交互被抽象并以非对称二人对局建模。这意味着，两名玩家分别扮演不同的角色，并且第一玩家的代理可用的策略集合与第二玩家的代理不同。事实上，对于更具体的情形，其中的交互形式为对称二人对局，算法3.1可以直接被重新表述为使用单一群体，并在过程上看起来更加类似于算法1.1所描述的进化算法框架。然而，在更一般化的非对称交互设置下，假设两名玩家的策略集合不同这一点将指向框架固有的其他设计特性。特别地，我们注意到一个显著特征，即存在两个基因上相互隔离的种群。

在协同优化的语境中，[41]，候选解组成的种群表示为 $\boldsymbol{X}_{\mathbf{s}} = \big((\boldsymbol{x}_{\mathbf{s}}, f)_i : i = 1, 2, 3, \ldots, n\big)$，而测试案例组成的种群表示为 $\boldsymbol{X}_{\mathbf{t}} = \big((\boldsymbol{x}_{\mathbf{t}}, f)_i : i = 1, 2, 3, \ldots, m\big)$。注意，在协同进化计算领域的文献中，其他术语已经被提出并使用。有些术语受生物学的启发，包括捕食-猎物和宿主-寄生虫协同进化[4, 24, 46]。然而，这些协同进化系统在过程上可以被竞争性协同进化框架所描述，该框架于本文中引入并讨论。

算法3.1所描述的框架将竞争性协同进化定义为一个包含两个基因隔离种群的过程，每个种群依次对另一个种群进行适应性调整。竞争性CEA的通用框架通过主要过程CMCEA来实现，该过程明确表明候选解种群 $\boldsymbol{X}_{\mathbf{slocal}}$ 通过方法EVOLPOPSOL进行适应，而测试案例种群 $\boldsymbol{X}_{\mathbf{tlocal}}$ 通过方法EVOLPOPTEST进行适应。这两个种群的基因隔离至关重要，因为适应性过程应用于特定种群中的代理的机制在两种角色之间有所不同。例如，在变异操作方面，将调用和执行变异操作器variationSol，它生成类型为 $\mathbb{R}^D$ 的个体候选解儿童 $({\boldsymbol x}_{\mathbf{s}})_i$。此变异操作过程会将生成的个体复制到全种群 $\boldsymbol{X}_{\mathbf{slocal}}$ 的一个分区中，然后返回新的完整种群 $\boldsymbol{X}_{\mathbf{slocal}}$。

我们有变异操作器variationTest用于种群 $\boldsymbol{X}_{\mathbf{tlocal}}$，通过生成和复制类型为 $\mathbb{R}^E$ 的个体子测试案例 $({\boldsymbol x}_{\mathbf{t}})_i \in \mathbb{R}^E$。variationSol 和 variationTest 的变异操作器在其具体说明上至少有所不同，因为 $\mathbb{R}^D \neq \mathbb{R}^E$。然而，这些变异操作器可以采用相似的机制（例如，本文1.2.3引入的实值变异操作器族）。类似地，基因隔离的必要性对于选择操作器也可以得到验证。一方面，选择操作器selectionSol作为一种类型为 $\boldsymbol{\mathcal{X}} \rightarrow \boldsymbol{\mathcal{X}}$ 的函数，作用于种群配置 $\boldsymbol{X}_{\mathbf{slocal}}$ 上整体。
**翻译结果：**

**输入：**  
$Y_s$ 候选解的种群  
$Y_t$ 测试用例的种群  
$sterm$ 终止准则选择  
$csol$ 候选解的演化循环终止准则选择  
$ctest$ 测试用例的演化循环终止准则选择  

**输出：**  
$X_s$ 已演化的候选解种群  

1: **程序** CMCEA($Y_s$, $Y_t$, $sterm$, $csol$, $ctest$)  
2: $t := 0$ ^ 初始化时间戳  
3: $bterm := \text{true}$ ^ 初始化循环条件  
4: $X_s := initializeSol(Y_s)$ ^ 初始化父代种群到 $X_s$  
5: $X_t := initializeTest(Y_t)$ ^ 初始化父代种群到 $X_t$  
6: **当** $bterm$ **为真时**  
7: $X_s := EVOLPOPSOL(X_s, X_t, csol)$ ^ 候选解的种群演化  
8: $X_t := EVOLPOPTEST(X_t, X_s, ctest)$ ^ 测试用例的种群演化  
9: $t := t + 1$ ^ 递增协同演化循环计数  
10: $bterm := termination(X_s, t, sterm)$ ^ 检查是否满足终止条件  
11: **结束循环**  
12: 返回 $X_s$  
13: **结束程序**  

14: **程序** EVOLPOPSOL($X_s$, $X_t$, $csol$)  
15: $cs := 0$ ^ 初始化循环时间戳  
16: $csolterm := \text{true}$ ^ 初始化循环条件  
17: $X_{slocal} := seedSol(X_s)$ ^ 初始化父代种群到局部种群 $X_{slocal}$  
18: **当** $csolterm$ **为真时**  
19: $X_{slocal} := variationSol(X_{slocal})$ ^ 对 $X_{slocal}$ 应用变异算子  
20: evaluationSol($X_{slocal}, X_t$) ^ 利用 $X_t$ 对 $X_{slocal}$ 进行适应度评估  
21: $X_{slocal} := selectionSol(X_{slocal})$ ^ 对 $X_{slocal}$ 应用选择算子  
22: $cs := cs + 1$ ^ 递增演化循环计数  
23: $csolterm := terminationSol(X_{slocal}, cs, csol)$ ^ 检查是否满足终止条件  
24: **结束循环**  
25: 返回 $X_{slocal}$  
26: **结束程序**  

27: **程序** EVOLPOPTEST($X_t$, $X_s$, $ctest$)  
28: $ct := 0$ ^ 初始化循环时间戳  
29: $ctestterm := \text{true}$ ^ 初始化循环条件  
30: $X_{tlocal} := seedTest(X_t)$ ^ 初始化父代种群到局部种群 $X_{tlocal}$  
31: **当** $ctestterm$ **为真时**  
32: $X_{tlocal} := variationTest(X_{tlocal})$ ^ 对 $X_{tlocal}$ 应用变异算子  
33: evaluationTest($X_{tlocal}, X_s$) ^ 利用 $X_s$ 对 $X_{tlocal}$ 进行适应度评估  
34: $X_{tlocal} := selectionTest(X_{tlocal})$ ^ 对 $X_{tlocal}$ 应用选择算子  
35: $ct := ct + 1$ ^ 递增演化循环计数  
36: $ctestterm := terminationTest(X_{tlocal}, ct, ctest)$ ^ 检查是否满足终止条件  
37: **结束循环**  
38: 返回 $X_{tlocal}$  
39: **结束程序**  

操作的类型是 $X \boldsymbol{\mathcal{X}}$。此操作包括接收种群配置作为输入，改变它的配置，将选定个体放入种群顶部部分（通过地址引用它们是父代的部分），并作为输出生成一个新的种群配置 $X_{slocal} = X_j \in \boldsymbol{\mathcal{X}}$，用于下一轮迭代。 

另一方面，选择操作 $selectionTest$ 以完全相同的方式作用于 $Y \boldsymbol{\mathcal{Y}}$。该函数类型为 $Y \rightarrow Y \boldsymbol{\mathcal{Y}} \rightarrow \boldsymbol{\mathcal{Y}}$，接收种群配置作为输入，对其进行改变，并作为输出生成种群配置 $X_{tlocal} = Y_j \in \boldsymbol{\mathcal{Y}}$。 

之前我们已经指定了候选解和测试用例的种群形式如下：  
\[
\left( (x_s, f)_i : i = 1, 2, 3, \dots, n \right)
\]
\[
\big(({\boldsymbol x}_{\mathbf{s}},f)_i : i = 1,2,3,\ldots,n\big) \text{和} 
\big(({\boldsymbol x}_{\mathbf{t}},f)_i : i = 1,2,3,\ldots,m\big)
\]
分别对应。由此可见，选择操作在\texttt{selectionSol}和\texttt{selectionTest}中至少在其指定有所不同，因为配置空间不同（即$\boldsymbol{\mathcal X} \neq \boldsymbol{\mathcal Y}$，如果$n \neq m$）。尽管可以使用具有相同机制的选择操作（例如在1.2.4中描述的锦标赛选择），但我们在\texttt{EVOLPOPSOL}中使用变量名$\boldsymbol{X}_{\!\mathbf{slocal}}$，在\texttt{EVOLPOPTEST}中使用变量名$\boldsymbol{X}_{\!\mathbf{tlocal}}$，以强调局部适应过程应用于候选解和测试用例的种群，因此保持遗传隔离。然而，这两个种群通过评估种群成员适应度或性能的过程相互作用。例如，\texttt{evaluationSol}将使用$\boldsymbol{X}_{\!\mathbf{tlocal}}$来对$\boldsymbol{X}_{\!\mathbf{slocal}}$进行更新，具体而言，这会更新所有个体适应度值：
\[
({\boldsymbol x}_{\mathbf{s}},f)_i, \ i = 1,2,3,\ldots,n
\]
此处，变量名为$f$，并通过$\boldsymbol{X}_{\!\mathbf{slocal}}[i].f$地址访问。同样地，\texttt{evaluationTest}使用$\boldsymbol{X}_{\!\mathbf{slocal}}$来更新$\boldsymbol{X}_{\!\mathbf{tlocal}}$中的适应度值。

在同时考虑\texttt{EVOLPOPSOL}和\texttt{EVOLPOPTEST}均使用演化适应过程时，程序上可以将\texttt{CMCEA}描述为一个具有耦合的适应度评估的协同演化系统。参数$c_{\mathrm{sol}}$和$c_{\mathrm{test}}$分别控制了\texttt{EVOLPOPSOL}和\texttt{EVOLPOPTEST}适应过程的持续时间。这两个参数中的任意一个决定了在当前种群上终止之前，在\texttt{EVOLPOPSOL}或\texttt{EVOLPOPTEST}的相应过程中进行的包括变异和选择操作（包括种群成员的适应度评估）重复演化周期的次数。它们分别由变量$c_s$和$c_t$进行跟踪，对应于\texttt{EVOLPOPSOL}或\texttt{EVOLPOPTEST}。

随后，主程序\texttt{CMCEA}将调用并执行另一种群上的演化适应过程。这种\texttt{EVOLPOPSOL}和\texttt{EVOLPOPTEST}的重复调用和执行序列将持续进行，直到主程序\texttt{CMCEA}循环的终止判据$\mathrm{s}_{\mathrm{term}}$通过对标志$\mathrm{b}_{\mathrm{term}}$的更改触发时，从而退出循环结束协同演化过程的计算模拟。终止判据可以是循环固定迭代次数，也可以是其他更复杂的方案，每种方案都记录在终止判据中，并由$\mathrm{s}_{\mathrm{term}}$选择执行。注意，一个完整的协同演化周期指的是在主程序\texttt{CMCEA}的主循环中完成对\texttt{EVOLPOPSOL}和\texttt{EVOLPOPTEST}的执行，该过程由变量$t$进行跟踪。

### 3.2.2 协作协同演化
我们提出了合作协同演化算法 (cooperative CEA) 的通用框架，其描述如算法3.2所示。在该框架中，我们假设的基本情景涉及加性可分问题 (additively separable problems) 的问题族，这类问题允许如下的分解处理：

**算法 3.2 一般的合作协同演化算法**
输入：
$D$ — 问题的维度  
$N$ — 个体种群规模  
$f_{\mathrm{sel}}$ — 从加性可分问题库中选择的问题  
$s_{\mathrm{term}}$ — 总体终止准则选择  
$c_{\mathrm{sol}}$ — 个体种群演化循环的终止准则选择  

输出：  
$x$ — 演化后的候选解决方案  

```
1: procedure COCEA($f_{\mathrm{sel}}, D, N, s_{\mathrm{term}}, c_{\mathrm{sol}}$)  
2:   $t := 0$  // 初始化时间戳  
3:   $b_{\mathrm{term}} := \mathrm{true}$  // 初始化循环  
4:   $F := \mathrm{problemDecom}(D, f_{\mathrm{sel}})$  // 根据问题分解初始化结构$F$  
5:   $b := \mathrm{initContext}(D, F)$  // 随机初始化上下文向量 $b$  
6:   $f_b := \mathrm{evaluate}(b)$  // 设置 $f_b = f(b)$  
7:   for $i = 0 : F.m$ do  
8:       $X_i := \mathrm{initializeSubPop}(D, N, F, i)$  // 初始化$F.m$子组件的种群  
9:   end for  
10:  while $b_{\mathrm{term}}$ do  
11:      $b := \mathrm{EVOLPOPSOL}(f_{\mathrm{sel}}, D, N, X_i, F, i, b, f_b, c_{\mathrm{sol}})$  // 演化第$i$个子组件的种群  
12:      $t := t + 1$  // 协同演化周期计数+1  
13:      $b_{\mathrm{term}} := \mathrm{termination}(b, t, s_{\mathrm{term}})$  // 检查终止准则  
14:  end while  
15:  $x := b$  
16:  return $x$  
17: end procedure  

18: procedure $\mathrm{EVOLPOPSOL}(f_{\mathrm{sel}}, D, N, X_i, F, i, b, f_b, c_{\mathrm{sol}})$  
19:   $c_s := 0$  // 初始化周期时间戳  
20:   $c_{\mathrm{solterm}} := \mathrm{true}$  // 初始化循环  
21:   $X_s^{\mathrm{local}} := \mathrm{seedSol}(X_i)$  // 在$X_s^{\mathrm{local}}$中播种父代种群  
22:   while $c_{\mathrm{solterm}}$ do  
23:       $X_s^{\mathrm{local}} := \mathrm{variationSol}(N, X_s^{\mathrm{local}}, F, i)$  // 在$X_s^{\mathrm{local}}$上应用变异算子  
24:       $\mathrm{evaluationSol}(f_{\mathrm{sel}}, N, X_s^{\mathrm{local}}, F, i, b)$  // 对$X_s^{\mathrm{local}}$进行适应度评估  
25:       $b := \mathrm{updateContext}(D, N, X_s^{\mathrm{local}}, F, i, b, f_b)$  // 更新上下文向量 $b$  
26:       $f_b := \mathrm{evaluate}(b)$  // 更新 $f_b = f(b)$  
27:       $X_s^{\mathrm{local}} := \mathrm{selectionSol}(N, X_s^{\mathrm{local}})$  // 在$X_s^{\mathrm{local}}$上应用选择算子  
28:       $c_s := c_s + 1$  // 演化周期计数+1  
29:       $c_{\mathrm{solterm}} := \mathrm{terminationSol}(X_s^{\mathrm{local}}, c_s, c_{\mathrm{sol}})$  // 检查终止准则  
30:   end while  
31:   return $b$  
32: end procedure  
```

分解的意义在于，$D$维问题的目标函数可以表示为  
$$f(\mathbf{x}) = \sum_{i=1}^{m} f_i(\mathbf{x}_i)$$  
其中，问题由至多$m \leq D$个独立的子组件 $\mathbf{x}_1, \ldots, \mathbf{x}_m$ 组成。我们的框架类似于最近合作协同演化算法综述文章[30]中所提出的框架，该框架是基于文献[43]中介绍的合作协同演化框架。然而，与其框架中将问题分解成$D$个一维子问题的情形 (即$m=D$) 不同，我们提出了一种通用框架，适用于$m \leq D$的情形。事实上，这一需求是明确的，主过程$\mathrm{COCEA}$接受来自加性可分问题库中的问题选择$f_{\mathrm{sel}}$作为输入之一。
一般的协同协作进化算法（Cooperative Co-Evolutionary Algorithm，COCEA）通过主程序COCEA来实现。在初始设置后，COCEA会调用问题分解程序problemDecom，该程序对选定的问题进行分解。分解过程的输出为一个数据结构$\boldsymbol{F}$，其捕获和表示的问题分解信息，包括将非独立的决策变量分组到子组件$\boldsymbol{x}_1, \ldots, \boldsymbol{x}_m$中。这是通过捕获并分组决策变量向量$\boldsymbol{x} = (x_1, \ldots, x_D)$中的相关索引编号来实现的，并将这些值作为相应子组件的存储内容。设定整数集合${\mathbb{Z}}_{1 \leq z \leq D} = \{1, 2, 3, \ldots, D\}$表示索引$\boldsymbol{x}$中的决策变量。数据结构$\boldsymbol{F}$可以描述如下：

\[
\boldsymbol{F} = (m, \boldsymbol{s}, \mathbf{IDX}),
\]
\[
m \in {\mathbb{Z}}_{1 \leq z \leq D},
\]
\[
\boldsymbol{s} = (s_{i} : i = 1,\ldots,m), \; s_{i} \in {\mathbb{Z}}_{1 \leq z \leq D},
\]
\[
\mathbf{IDX} = (\mathbf{idx}_{i} : i = 1,\ldots,m),
\]
\[
\mathbf{idx}_{i} = (\mathrm{index}_{i,j} : j = 1,\ldots,s_{i}), \;\mathrm{index}_{i,j} \in {\mathbb{Z}}_{1 \leq z \leq D}.
\]

这里，式(3.1)中的$\boldsymbol{F}.m$表示问题分解后不相交的子组件数量；$\boldsymbol{F}.\boldsymbol{s}[i]$表示第$i$个子组件$\boldsymbol{x}_i$所对应向量的维数，其为区间$1$到$D$中的正整数$s_i$；$\boldsymbol{F}.\mathbf{IDX}[i] = (\mathrm{index}_{i,1}, \ldots, \mathrm{index}_{i, s_i})$是一个维度为$s_i$的向量，其中每个正整数$\mathrm{index}_{i,j}$ $(j = 1,\ldots,s_i)$都来自集合${\mathbb{Z}}_{1 \leq z \leq D}$。实质上，这是一个正整数列表，每个整数表示决策变量向量$\boldsymbol{x} = (x_z : z = 1, 2, \ldots, D)$中与第$i$个子组件$\boldsymbol{x}_i$相关的索引编号。

这种问题分解具有两个性质或不变量。首先，有以下关系：
\[
\sum_{i = 1}^m s_i = D.
\]
其次，列表中所有正整数$\boldsymbol{F}.\mathbf{IDX}[i]$的并集，即如下形式的整数：
\[
\mathrm{index}_{i,j}, \; i = 1,\ldots,m, \; j = 1,\ldots,s_i,
\]
实际上是区间$1$到$D$的一个排列。

在实际实现中，数据结构$\boldsymbol{F}$被所有其他程序用作子组件以及其相关决策变量的索引。这种分解可以通过如下示例来说明：考虑一个加性可分的问题，其决策向量为$\boldsymbol{x} = (x_1, x_2, x_3)$，该问题可以被分解为$f(\boldsymbol{x}) = \sum_{i=1}^2 f_i(\boldsymbol{x}_i)$。具体而言，$\boldsymbol{x}_1 = (x_2)$和$\boldsymbol{x}_2 = (x_1, x_3)$。（注意，此处我们稍微偏离标准符号约定，使用变量列表来表示向量。）问题分解程序problemDecom返回以下结果：
**公式和符号定义：**

$ \boldsymbol{F} = (m, \boldsymbol{s}, \mathbf{IDX}), \\ m = 2, \\ \boldsymbol{s} = (s_1, s_2) = (1, 2), \\ \mathbf{IDX} = (\mathbf{idx}_{1}, \mathbf{idx}_{2}), \ \mathbf{idx}_{1} = (2), \ \mathbf{idx}_{2} = (1, 3).$

**正文翻译：**

算法 3.2 可以利用问题的分解结构，该结构通过 $ \boldsymbol{F} $ 描述和表示，从而以协作的方式解决可加性可分问题的优化问题。这通过使用上下文向量 $ \boldsymbol{b} $ 和在 $2 \leq m \leq D$ 区间内的遗传隔离种群的逐步适应过程来实现。上下文向量 $ \boldsymbol{b} $ 在这种协作的协同演化算法 (CEA) 框架中执行两个重要功能：（1）它表示当前完整解，通过从每个第 $i$ 个种群中选择个体来组装 $ \boldsymbol{b} = (\boldsymbol{b}_i : i = 1,\ldots,m)$，即 $ \boldsymbol{b}_i \in \boldsymbol{X}_i.\boldsymbol{x}$。这一过程是在所有 $m$ 个种群的演化适应过程（通过程序 EVOLPOPSOL）完成后进行。（2）它提供了评估代表第 $i$ 个子组件 $ \boldsymbol{x}_i $ 的候选解的适应性或性能的方法，这在第 $i$ 个种群的演化适应过程中尤为重要，因为每个子组件的适应性函数 $ f_i $ 通常是未知的（例如，在黑盒优化中）。上下文向量 $ \boldsymbol{b} $ 的第一个功能与计算当前完整解的适应性函数 $ f(\boldsymbol{b}) $ 的程序 evaluate 相关。在算法 3.2 开始时，通过程序 initContext 对上下文向量 $ \boldsymbol{b} $ 进行初始化。可以采用通常的方式通过随机采样 $\mathbb{R}^D$ 来完成，也可以采用更复杂的初始化过程，例如使用已知解进行种子化。更重要的是，在第 $i$ 个种群 $ \boldsymbol{X}_i $ 的演化适应过程 EVOLPOPSOL 中，上下文向量 $ \boldsymbol{b} $ 会通过程序 updateContext 按顺序更新第 $i = 1,\ldots,m$ 个子组件。

考虑一个目标函数 $ f(\star)$ 为可加性可分的最小化问题，该问题具有正确的结构分解 $ \boldsymbol{F} $ 且已知子组件适应性函数 $ f_i, \ i = 1,\ldots,m$。更新后的第 $i$ 个子组件的选择为：

$ 
\boldsymbol{b}_i = \mathop{\mathrm{argmin}}_{\boldsymbol{x}_{i,k} \in \boldsymbol{X}_i.\boldsymbol{x}} f_i(\boldsymbol{x}_{i,k}) = \mathop{\mathrm{argmin}}_{\boldsymbol{x}_{i,k} \in \boldsymbol{X}_i.\boldsymbol{x}}\big(f_i(\boldsymbol{x}_{i,k}) + C\big).
$

在第 $ i $ 个子组件的更新过程中，常数项为：

$ 
C = \sum_{j \in \{1,\ldots,m\} \backslash \{i\}} f_j(\boldsymbol{b}_j).
$

这是一个固定值，因为所有其他子组件 $\{\boldsymbol{b}_1,\ldots,\boldsymbol{b}_m\} \backslash \{\boldsymbol{b}_i\} $ 都保持不变或保留之前选择的状态。因此事实上，有：

$ 
\boldsymbol{b}_i = \mathop{\mathrm{argmin}}_{\boldsymbol{x}_{i,k} \in \boldsymbol{X}_i.\boldsymbol{x}} f_i(\boldsymbol{x}_{i,k}).
$

然而，这无法直接实现，因为 $ f_i $ 是未知的。实际的第 $i$ 子组件更新的实现需要比较 $ f(\boldsymbol{x}_{i,k} \cup \boldsymbol{b}^c) $，其中 $ \boldsymbol{b}^c $ 为所有其他子组件的精选个体。值 $ f(\boldsymbol{x}_{i,k} \cup \boldsymbol{b}^c) $ 作为 $ f_i(\boldsymbol{x}_{i,k} + C) $ 的代理，用于确定哪个候选解 $ \boldsymbol{x}_{i,k} $ 满足：

$ 
\min_{\boldsymbol{x}_{i,k} \in \boldsymbol{X}_i.\boldsymbol{x}}\big(f_i(\boldsymbol{x}_{i,k}) + C\big).
$

其中 $ \boldsymbol{x}_{i,k} \cup \boldsymbol{b}^c $ 表示完整解向量。此过程用于通过完整解的适应性 $ f(\boldsymbol{x}_{i,k} \cup \boldsymbol{b}^c) $ 计算 $ f_i(\boldsymbol{x}_{i,k}) $，称为补全过程。
**EVOLPOPSOL过程**

EVOLPOPSOL方法实现了针对每个第$i$个群体$X_i = \big(({\boldsymbol x}_{i},f)_k : k = 1,\ldots,N\big)$的进化适应过程，其中该群体由第$i$个子组件的个体候选解${\boldsymbol x}_{i,k}$组成。这一过程与任何进化算法（EA）相同，由参数$\mathrm{csol}$控制进化过程或进化周期的持续时间（例如，进化操作被重复调用的次数），这由变量$c_s$记录。

唯一的例外是子组件${\boldsymbol x}_i, \ i = 1,\ldots,m$可能拥有不同的维度$s_i, \ i = 1,\ldots,m$，因此用于生成子代候选解的变异算子$\mathrm{variationSol}$需要问题分解结构$\boldsymbol F$的信息；而选择用于下代的父代的选择算子$\mathrm{selectionSol}$需要群体大小$N$的基本信息。虽然可以为每个第$i$个子组件选择不同的群体大小$N_i$，但这个参数对于所有群体是固定的。

群体中每个候选解${\boldsymbol x}_{i,k}$的适应度评估通过过程$\mathrm{evaluationSol}$来实现。此过程需要当前的上下文向量${\boldsymbol b}$，候选解${\boldsymbol x}_{i,k}$的适应度通过以下公式计算：
$${\boldsymbol X}_i[k].f = f({\boldsymbol x}_{i,k} \cup {\boldsymbol b}^c).$$
最后，EVOLPOPSOL还实现了过程$\mathrm{updateContext}$，用于在上下文向量中选择第$i$子组件的最佳候选解。对于加性可分问题并基于正确的问题分解$\boldsymbol F$，上下文向量的第$i$个分量通过以下公式生成：
$${\boldsymbol b}_i = \mathop{\mathrm{argmin}}_{{\boldsymbol x}_{i,k} \in {\boldsymbol X}_i.{\boldsymbol x}}\big(f_i({\boldsymbol x}_{i,k}) + C\big) = \mathop{\mathrm{argmin}}_{{\boldsymbol x}_{i,k} \in {\boldsymbol X}_i.{\boldsymbol x}}f_i({\boldsymbol x}_{i,k}).$$

当针对$i = 1,\ldots,m$的EVOLPOPSOL过程调用序列对应的协同进化周期完成后，可获得原始问题的完整候选解，其形式为：
$${\boldsymbol b} = \big(\mathop{\mathrm{argmin}}_{{\boldsymbol x}_{1,k} \in {\boldsymbol X}_1.{\boldsymbol x}}f_1({\boldsymbol x}_{1,k}),\ldots,\mathop{\mathrm{argmin}}_{{\boldsymbol x}_{m,k} \in {\boldsymbol X}_m.{\boldsymbol x}}f_m({\boldsymbol x}_{m,k})\big).$$

协同进化算法（CEA）的终止准则由$\mathrm{s}_{\mathrm{term}}$指定，可以包括固定迭代次数或通过变量$t$记录的协同进化周期，或者利用更复杂的机制，例如检测群体的（过早）收敛。关键的是，最终更新的上下文向量${\boldsymbol b}$是性能最佳的一个，并在终止时由主过程$\mathrm{COCEA}$返回作为最终解。

---

**3.3 协同进化问题解决**

在第2章中，我们概述了协同进化计算的相关文献，并讨论了协同进化系统在解决各种现实世界问题中的发展。特别是，我们重点讨论了协同进化系统的两个通用设置：学习和优化。这两种设置已被广泛研究。

第2.4.2节表明，竞争性协同进化用于学习，而合作性协同进化用于优化，这两者基于在两种协同进化方法中群体交互的特定形式。这些形式被利用，并随后被制定为竞争性和合作性协同进化算法框架中的核心机制，用于性能或适应度评估。

在先前的第3.2节中，我们介绍了这些算法框架。此处，我们将更详细地讨论这些通用协同进化框架如何应用于学习和优化的两种问题解决设置。我们的讨论将以实例为驱动，并详细探讨文献中提出的设计问题，这些问题旨在应对上述问题解决设置中的固有挑战。
### 3.3.1 用竞争协同进化进行学习

我们从单种群的竞争性协同进化算法（competitive coevolutionary algorithms, CEA）讨论学习问题开始。在这种方法下，种群中的任何代理都可以同时充当候选解和测试案例的角色。事实上，这种单种群配置仅在竞争性CEA中较为常见。在这里，竞争性协同进化学习为搜索博弈策略提供了一种替代方法。对于这种设置，要么已经知道游戏是对称的，因此两位玩家的博弈策略集合相同，要么可以假设游戏是近似对称的。这种假设已被广泛应用于涉及两名玩家轮流顺序移动的棋盘类游戏，如跳棋 [5]、黑白棋 [8]、国际象棋 [18] 和围棋 [47]等。甚至可以进一步假设协同进化的策略必须能够学习玩两种颜色（即作为先手和后手），并据此制定适当的适应度评估，以考虑作为先手和后手对任何测试对手策略的表现。

我们以两位玩家的对称性博弈问题，即对称IPD（Iterated Prisoner’s Dilemma，迭代囚徒困境）游戏的学习策略的竞争性协同进化为例进行展开 [3, 6, 11, 15, 16, 19]。对于这种设置，竞争性CEA与通用进化算法EA（例如算法1.1所描述的）类似，主要的原则性区别在于种群中博弈代理的适应度评估是基于博弈的表现。设计进化算法以解决特定问题时所经历的过程同样适用于竞争性协同进化算法，尤其在解决方案或策略表示的设计选择上，这对进化操作符，尤其是变异操作符具有重要影响。

一个两位玩家的IPD游戏涉及由两名玩家同时作出联合动作的一个序列，游戏设定为固定的轮数。在每一轮中，玩家可以选择合作（C，cooperate）或背叛（D，defect）。基于记忆的反应式策略通过参考过去玩家自身、对手或双方联合动作的历史记录，来决定当前动作。这种策略得到了广泛研究。例如，在开创性的研究 [3] 中，将协同进化学习过程限制为在记忆长度为三的反应式IPD策略的空间中进行搜索。这种策略可以表示为一个查找表（look-up table），记录过去的三次联合动作，其中包含 $(2^{2})^3 = 64$ 条目。（注意：每轮中可能的联合动作为 $(C, C), (C, D), (D, C), (D, D)$）。每条目记录玩家的选择动作，即合作（C）或背叛（D），用表现地址 $p_{\mathrm{addr}}$ 表示。查找表的每个条目位置由过去三次联合动作的信息进行寻址。

完整的地址列表 $\boldsymbol{A}$ 包含 $|\{\mathrm{C},\mathrm{D}\}|^{|\{1,2\} \times \{1,2,3\}|} = 2^6 = 64$ 个元素，其中每个地址 $\mathrm{addr}$ 的定义如下：
\[
\mathrm{addr} = 
\{ 
(m \in \{\mathrm{C}, \mathrm{D}\}, i, r) : i = 1, 2, r = 1, 2, 3
\}.
\]
$\mathrm{addr} = \big((m \in \{\mathrm{C},\mathrm{D}\},i,r) : \ i = 1,2, \ r = 1,2,3\big)$被表示为一个包含六个三元组的列表，其中，索引$i = 1, 2$表示做出操作的玩家（1表示自己，2表示对手），索引$r = 1, 2, 3$指的是前$r$轮。三轮联合行动的历史记录包含六个动作，索引$i,r$在$\mathrm{addr}$中被使用来确定策略和历史动作与哪位玩家及哪个回合相关。例如，当两位玩家在前三轮均选择合作时，第一个玩家将这一历史记录处理为：
$$\mathrm{addr} = ((\mathrm{C}, 1, 1), (\mathrm{C}, 2, 1), (\mathrm{C}, 1, 2), (\mathrm{C}, 2, 2), (\mathrm{C}, 1, 3), (\mathrm{C}, 2, 3)).$$

接下来，策略被定义为映射${\boldsymbol T}: {\boldsymbol A} \rightarrow \{\mathrm{C},\mathrm{D}\}$，其形式为：
$${\boldsymbol T} = \big( p_{\mathrm{addr}} \in \{\mathrm{C},\mathrm{D}\} : \mathrm{addr} \in {\boldsymbol A} \big),$$
其中输出值取自查找表中的对应项：
$${\boldsymbol T}(\mathrm{addr}) = p_{\mathrm{addr}} \in \{\mathrm{C},\mathrm{D}\}.$$

注意，在前三轮中，没有足够的历史联合动作可以通过查找表${\boldsymbol T}$访问。因此，任何基于内存的反应型策略必须额外设计机制，以便在完整的历史联合动作不可用时启动操作。在文献[3]中，这种机制涉及为每种策略假设三轮初始历史记录，因此策略能够通过处理这些假设的历史记录来定位查找表中特定条目，并输出${\boldsymbol T}(\mathrm{addr})$。至此，基于三轮记忆的反应型IPD（囚徒困境）策略已完全被定义。

该研究进一步采用遗传（二值）编码方案来表示策略。由于查找表${\boldsymbol T}$中存在$(2^2)^3 = 64$个元素（条目），以及假设的历史记录需要额外的$(2+2+2)=6$个元素，因此编码方案将生成长度为70的二进制字符串。每个位与特定元素相关联，可以任意指定0表示$\mathrm{C}$（合作），1表示$\mathrm{D}$（背叛）。这种策略表示的遗传编码方案允许使用遗传算法（GA）实现竞争性协同进化算法（CEA）以搜索IPD策略。在文献[3]中，使用了一个包含20个个体的种群。变量操作包括单点交叉和较低概率的位翻转突变（bit-flip mutation）。选择操作采取按频率成比例的方式进行。每个种群个体的适应度评估通过计算其从所有对局中获得的IPD游戏总收益来进行。每个个体与种群中其他19个个体进行对抗（不包括自我对决）。在每场对局中，某个个体基于特定IPD策略的总收益由其与对手在151轮中进行联合动作的结果累计获得。

IPD游戏收益对于第一玩家由收益矩阵$\mathbf{G} = (g_{ij} : i,j = \mathrm{C},\mathrm{D})$定义，其中索引$i$表示第一位玩家的（行）选择，索引$j$表示第二位玩家的（列）选择。对于任意两玩家、两选择的IPD游戏，该收益矩阵$\mathbf{G}$包含四个非负实数：
$$(R, S, T, P) = (g_{\mathrm{C}\mathrm{C}}, g_{\mathrm{C}\mathrm{D}}, g_{\mathrm{D}\mathrm{C}}, g_{\mathrm{D}\mathrm{D}}), \ R,S,T,P \in {\mathbb{R}}_{\geq 0},$$
其中四个变量$R, S, T, P$具有特定的游戏含义：互相合作的奖励（$R$）、当对手背叛时因受骗而获得的收益（$S$）、背叛的诱惑（$T$），以及彼此背叛的惩罚（$P$）[2]。这些变量需满足以下条件：

1. $T > R$ 且 $P > S$（背叛收益更高）；
2. $R > P$（互相合作收益高于互相背叛）；
3. $R > (T + S)/2$（交替操作收益低于互相合作收益）。

文献[3]中采用的参数值为$(R, S, T, P) = (3, 0, 5, 1)$，但其他满足IPD条件的值也可以使用。还需要通过适当的归一化方式将任何种群个体的适应度限定在$[S, T]$范围内，基于IPD游戏累计收益来进行评估。
请注意，设计单种群竞争性协同进化算法（CEAs）所涉及的一般原则也适用于具有假设对称策略集合的其他双人游戏。大部分具体细节集中在游戏策略的参数化表示和相关的变异算子的设计上。尤其是，人工神经网络（ANNs）已被广泛用于为基于棋盘状态评估函数的双人棋盘游戏提供游戏策略的参数化表示 [5, 8, 18, 47]。在大多数研究中，设计并应用了基于实数值的变异算子，以生成由ANN表示的新游戏策略。例如，[47]中的竞争性CEA通过加权线性函数对围棋棋盘状态进行评估。这些评估函数被表示为具有非线性双曲正切输出函数的单节点人工神经网络。研究过的竞争性CEAs包括精英策略 $(1+\lambda)$-ES 和非精英策略 $(1,\lambda)$-ES（即种群中的单一父代始终被最佳子代替代）。此外，研究的变异算子涉及两种非各向同性的突变操作：一种使用固定的 $\sigma_i$，另一种采用自适应的 $\sigma_i$（可以参阅第1.2.3节了解更多细节）。更复杂的人工神经网络结构也被使用，例如[5, 8, 18]中提到的多层感知器（MLPs）。然而，当然可以设计更复杂的策略表示与变异算子组合，这些组合可以演化表示结构（例如，ANN的拓扑结构），或通过引入游戏领域知识实现用户设计的固定结构（例如，[18]中使用了三个专注于国际象棋棋盘不同区域的ANN）。

如前所述，对于双人顺序棋盘游戏，可以提供更复杂的论证，以支持竞争性CEA同时学习第一玩家和第二玩家游戏策略的应用。例如，[47]研究使用了一种常见的循环赛选择算子，即一个智能体将与种群中的所有其他智能体进行游戏，但不进行与自身的对战。此外，适应度评估会考虑两个玩家角色，在每对智能体间的游戏对战中，会进行两局比赛，两个智能体分别轮流担任第一玩家和第二玩家。游戏结果定义为 $(\mathrm{win}, \mathrm{lose}, \mathrm{draw}) = (1, -2, 0)$，不同于通常的零和形式，输掉游戏的智能体受到双倍惩罚，而获胜智能体仅获得一次奖励。在竞争性协同进化学习环境中，此类任意规定并不罕见 [5]。但在其他游戏中，例如 Nim 和三维井字棋，第一玩家和第二玩家的角色存在不同。在这两种游戏中，第一玩家拥有内在优势，例如通过最佳游戏策略能够确保胜利（Nim游戏），或利用游戏设计中的某些固有优势（三维井字棋）。这表明第一玩家和第二玩家具有不同的策略集合。

因此，可以采用双种群竞争性CEA，并为第一玩家策略设计协同进化学习。在这种设置下，第二玩家智能体种群将充当测试策略。[46]研究展示了这种双种群竞争性CEA的效用，其通过捕食者-猎物模型，与使用随机生成的固定第二玩家游戏智能体样本进行了比较。特别是，这种竞争性CEA引入了先进的协同进化设计特性，例如适应度共享，以鼓励第一玩家和第二玩家两个基因隔离种群之间的军备竞赛动态发展。
在竞争学习的语境下，这种动态行为是指协同进化为整个进化时间轴提供了一系列教育性测试策略序列，使第一玩家代理能够学习竞争并取得胜利。这与使用固定的随机测试策略样本的系统有所不同，在后一种情况下，系统执行的是进化学习。研究[46]指出，对于更复杂的游戏——尼姆游戏（Nim）来说，固定样本的测试策略对进化学习系统来说类似于一种缺乏梯度的粗糙适应度景观，更像是在一堆干草中寻找针（Needle in a Haystack）。固定样本中的测试策略没有足够的信息供进化学习发现第一玩家策略，以克服样本中少数几个难以应对的测试策略。相反，协同进化学习能够通过对系统进行额外机制的增强（例如区分并维护新的和独特的测试策略于外部存储库中），搜索那些随机采样无法找到的必要中间测试策略。

**3.3.2 协作协同进化优化**

协作协同进化通过一种“分而治之”的问题求解方法解决优化问题，此方法结合了问题分解与多种群协同进化搜索。该方法要求优化问题能够接受问题分解，从而产生更简单的问题子组件，每一个子组件各自被一个遗传上隔离的候选解种群独立针对性地进行优化与进化。这些种群并不是系统化地单独搜索每个独立子组件的最优解，而是通过种群间的交互实现协同搜索，以确保每次迭代后，针对各个子组件的候选解性能能够同时得到提升。这也意味着协作型协同进化算法（Cooperative CEAs）涉及多个同时进化的种群，其框架已在**3.2节**的算法框架中进行了阐述。这假设一个理想场景，即存在准确的程序能够将加性可分的优化问题正确地分解。特别地，该程序将输出子组件，确保相互作用的变量能够被正确地分组。如果该程序\texttt{problemDecom}无法对优化问题进行分解以产生更简单的子组件，而只能返回原始问题，那么协作协同进化算法将丧失其独特的搜索特性，并作为单种群进化算法（EA）运行。
然而，在实际应用中，即使对于加性可分的优化问题，在使用协作型共进化算法（Cooperative CEAs）时，可能对问题结构毫无事先认识（即所谓的黑箱优化问题）。在这种情况下，协作型共进化算法如果采用了错误的问题分解方式，可能会陷入伪最小值。伪最小值的产生源于以下因素：子组件之间的交互作用与相关种群演化序列的综合影响，使得协作搜索偏向于这些伪最小值。近期的调查文献 [30] 为这种伪最小值的形成以及被协作型共进化算法搜索的方式提供了一个简单的示例，可在附录文档中查阅。此外，文献 [12] 中关于适应度景观（Fitness Landscapes）的描述讨论了类似情况，即在连续优化问题中，由特定的二进制编码方案和单点突变引发的局部最小值的形成。在这两种问题设置中，合适的选择是采用一种表示方案，将这些互相影响的变量作为一个整体，并设计变化算子，使变量变化整体发生。

其他问题设置可能涉及复杂且高阶的变量间交互（例如超越两两变量依赖的高级关系），这些交互作用存在于高维优化问题的决策变量之间，从而使得问题分解变得更加困难 [32, 40, 55]。因此，研究人员已进行大量工作，以开发能够有效地将交互变量在各自子组件中进行分组的策略，作为问题分解的替代方案。这对于协作型共进化算法在处理这种黑箱加性可分优化问题的有效和高效运作至关重要。因此，本节关于协作型共进化算法在实际应用中的讨论将重点关注问题分解方面。这些变量分组策略包括静态机制、随机机制、基于关联学习机制、覆盖和层次化机制，以及基于领域知识的机制 [30]。我们将详细讨论前三种策略，这些策略随着机制复杂性的递增，展示了它们在协作型共进化算法实现中的问题与挑战。我们首先从简单的静态变量分组策略开始讨论。

此类别中的各种机制并未采用任何系统性的或学习程序来发现优化问题的潜在分解结构。它们基于固定和任意的方式将决策变量划分为组，以形成子组件。研究 [42] 首次提出了简单的静态变量分组方法，其中一个$D$维的优化问题被分解为$D$个一维子组件。每个子组件都与原问题中的一个特定决策变量相关联。该研究中开发的协作型共进化算法可通过算法3.2来描述，其实现采用了$D$个协同演化种群。演化程序$EVOLPOPSOL$使用遗传算法（GA），进而形成一种协作型共进化遗传算法（Cooperative Coevolutionary GA）。与基准遗传算法相比，该算法在优化完全可分的基准问题时更加有效。然而，对于决策变量之间具有相互依赖问题的情况，它的效果较差。不过，它仍然优于基准遗传算法，但代价是由于使用更加复杂的协作搜索机制而增加了计算成本。
其他静态变量分组策略已经被开发出来。例如，研究[52]提出了一种通用机制，该机制可以将$D$维优化问题静态地分解为$m$个子组件，每个子组件包含$s$个不同的决策变量，并且满足$D = m \times s$。虽然静态分解的$m$个子组件大小为$s$的各种组合可以被使用，但它们的有效性取决于原问题中决策变量之间的相互依赖程度。更重要的是，该研究采用了粒子群优化（PSO）方法用于构建一种名为EVOLPOPSOL的合作协同进化粒子群优化算法。这一奠基性研究[42]使用了遗传算法（GA），而在其他文献[28]中则使用了进化编程（EP）来实现EVOLPOPSOL，用于对每个子组件对应的候选解个体种群进行进化搜索。这表明，合作协同进化算法（CEA）体现了一种高层次的问题求解方法，如算法3.2框架所示。因此，如果适当调整任何演化算法（EA）使其能够针对子组件解的参数化表示形式进行搜索，都可以在这一框架中使用。几乎是独立于此的，可以设计各种变量分组策略并评估其与合作协同进化搜索的有效性。

随着机制设计复杂性的增加，下一个类别是随机变量分组策略。这一类别的机制设计旨在解决前一个类别所涉及的两个相关问题。具体来说，决策变量的分组在协同进化循环中是固定的，包括子组件的构成以及每个子组件的大小。随机变量分组策略的机制设计的一般思想是将分解过程移至协同进化搜索循环的一部分。在算法3.2的上下文中，这需要将过程`problemDecom`和其他相关操作（例如子组件种群的初始化或种子分配）移动到主程序`COCEA`的主循环中，并对用于执行各子组件解候选的进化搜索过程`EVOLPOPSOL`进行适当修改（例如，在算法3.2的框架中，这涉及将相关参数传递给该过程）。

一种更为直接的随机变量分组策略机制，将原问题分解为$m$个子组件，每个子组件大小为$s$。[25, 53]中的研究表明，问题分解在每次协同进化循环开始时执行。子组件的数量$m$及大小$s$在整个协同进化循环中是固定的。然而，从原问题表示为${\boldsymbol x} = (x_1,\ldots,x_D)$的决策变量中选择$s$个不同变量并分组为各自子组件${\boldsymbol x}_1,\ldots,{\boldsymbol x}_m$的过程则是随机进行的。实现上，可以简单地对列表$x_1,\ldots,x_D$进行排列，然后从左到右每$s$个决策变量进行分组以生成$m$个子组件。任何决策变量$x_i$被选入子组件${\boldsymbol x}_k$的概率将是均匀分布的。

尤为重要的是，研究[54]结合了组合论的观点，并提供了实例，表明在多个协同进化循环中有高度概率选择了一组决策变量在一起。这表明，使用此类随机变量分组策略的合作协同进化算法可以花足够多的循环时间共同进化具有相互依赖关系的决策变量。进一步的扩展研究包括实现具有可变大小的子组件，这些大小可以在协同进化循环中的不同阶段进行更改。在[26]中，介绍了一种系统方法，它涉及从集合$\{i \in {\mathbb{Z}}_{> 0} : D \mod s = 0 : s\} \backslash \{s^{*}\}$中选择一个子组件大小$s$，以均匀概率选择一个不同于当前大小$s^{*}$的大小$s$，如果不存在可量化的适应度改进。

另外一个例子则在[51]中引入，它考虑了一种自适应方法，在协同进化循环中同时改变子组件大小$s_i$和相关的种群大小$N_i$。对此配置的选择实施了比较阶段，通过对各种配置$(s_i, N_i), \ i = 1,\ldots,q$进行贪婪搜索，以确定能够提供最佳适应度改进的配置$(s_j, N_j)$。
变量分组策略的下一个类别涉及检测问题结构中的变量相互作用，以确定是否以及如何对优化问题进行分解。这是一个活跃的研究和开发领域，调查研究[30]将这些策略命名为“交互学习”，并列出了另外五个子类别。我们将它们及相关的文献研究列表如下：扰动方法 [34, 35, 55]、统计模型 [37, 45]、分布模型（例如进化数据分析(EDAs)） [32, 33]、近似模型 [27]和关联适应 [49]。在此我们进行简短讨论，重点关注基于扰动的机制，以更好地揭示加性可分优化问题中存在的变量交互问题。

我们从这些优化问题可能存在的成对交互开始，尽管相关机制已经被改进以处理更高阶的交互[55]。这些交互可以通过对决策变量引入特定扰动来揭示。设$f(\boldsymbol{x})=f(x_1,x_2,x_3,\ldots,x_D)$为维数为$D$的加性可分优化问题的目标函数或适应度函数。设正整数$i, j \in \{1,2,3,\ldots,D\}$且满足$i < j$。函数$f$对决策变量$x_i$的前向差分$\varDelta_{\delta,x_i}f(\boldsymbol{x})$以及间隔$\delta > 0$定义为：
$$
\varDelta_{\delta,x_i}f(\boldsymbol{x}) = f(\ldots,x_i + \delta,\ldots) - f(\ldots,x_i,\ldots)。
$$

需要注意的是，仅显式写出的决策变量$x_i$发生了变化，在上述差分的两项中，左侧的$f(\star)$中有$x_i + \delta$，而右侧则为$x_i$。水平省略号符号“$\ldots$”表示其他决策变量保持不变。此外，前向差分$\varDelta_{\delta,x_i}f(\boldsymbol{x})$在替代值$x_i = a$和$x_j = b$的情况下，可写为：
$$
\varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b}。
$$

研究[38]对连续加性可分优化问题$f$（即，关于任意$x_i$的偏导数$\delta f / \delta x_i$存在）建立了一个理论结果。特别地，研究证明了非可分条件，即当满足如下条件：
$$
\varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_1} \neq \varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_2}
$$
对于所有实数$a, b_1 \neq b_2, \delta > 0$，任意决策变量对$x_i$和$x_j$为非可分。

实际上，证明是通过建立上述语句的反命题进行的。这个结果在实践中更具实用性，因为它暗示当以下条件满足时，变量$x_i$与$x_j$不存在交互（即变量对$(x_i, x_j)$是可分的）：
$$
\varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_1} \approx \varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_2}。
$$
换言之，如果对$x_i$施加扰动$\delta$所引起的前向差分，在用不同值$b_1$和$b_2$替代$x_j$时评估后结果相近（例如，两者差异在阈值$\epsilon > 0$以内），则变量对$(x_i,x_j)$可被认定为没有交互。

基于扰动的分组机制可以据此设计，通过检测成对交互的方法。例如，差分分组(Differential Grouping, DG) [38]和通过非线性检测的关联识别(Linkage Identification by Nonlinearity Check, LINC) [35]方法均属于此类机制。具体而言，可以设置参数$\epsilon > 0$并检查以下两个前向差分是否在阈值$\epsilon$范围内：
$$
\varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_1}
$$
和
$$
\varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_2}。
$$
进而确定变量对$(x_i, x_j)$是否存在交互关系。
我们将以对合作协同进化算法（Cooperative CEA）框架中的协作选择策略的简要讨论结束本节。从两个方面考虑，来自表示其他子组件的种群的候选解决方案的协作对于算法是至关重要的。首先是如何选择每个子组件的候选解决方案，以组成完整的解决方案。其次是根据为其他子组件所做出的选择进行子组件候选解决方案的适应度评价。针对协作选择策略已经开发了多种机制，其中调查研究文献[30]指出了其操作中具有区分性的两个主要因素：(i) 协作者选择压力（Collaborator selection pressure），它与选择来自子组件种群的候选解决方案以形成完整解决方案的贪婪程度或水平相关。(ii) 协作者选择规模（Collaborator selection size），它对应于用于评价子组件种群候选解决方案适应度的完整解决方案的数量。

我们重点介绍三种相关机制，分别是最佳（best）、随机（random）和精英（elite）协作者选择。关于最佳协作者选择策略的第一种机制[38, 42]已在算法3.2中制定，使用了一种贪婪方法来评价每个子组件的候选解决方案的适应度，同时选择其中一个作为代表性子组件解决方案以组成完整解决方案。需要注意的是，在正确的分解下，针对加法可分的优化问题，两个方面的协作选择——形成完整解决方案和对子组件候选解决方案的适应度评价——可以相互解决。然而，对于分解不正确的、子组件之间存在相互依赖的问题而言，最佳协作选择策略的贪婪特性在这些情况下并不适用。

随机协作选择策略[13, 39]可以作为一种替代方案。该机制随机选择每个子组件种群中的候选解决方案以形成完整解决方案。对于精英协作者选择策略[21]，机制将从协作者池中每个种群规模为$N$的种群中选取$K$个候选解决方案，然后随机从池中选择候选者以组成完整解决方案。参数$K$控制从各个种群中选择候选解决方案时的贪婪程度，其范围是$[1, N]$。当$K=1$时，策略作为最佳协作者选择策略运行，贪婪程度达到最大，因为总是选择种群中的最佳候选解决方案。而当$K=N$时，该策略的运行方式与随机协作者选择策略一致。
### 3.4 结论性评论与进一步阅读建议

我们提供了两种基于协同进化原理的算法框架，旨在搜索具有卓越性能的解决方案，并更详细地讨论了这些框架在一些问题示例中的具体实现方式。第一种框架涉及竞争性协同进化算法（Competitive CEA），用于在学习设定中解决问题。第二种则关于合作性协同进化算法（Cooperative CEA），适用于优化问题设定。

对于学习问题中的竞争性协同进化算法，交互形式表现为一个双人竞争性游戏，其中候选解决方案和测试案例分别扮演第一玩家和第二玩家角色。竞争性协同进化算法的主要设计原则在于依靠两组遗传隔离的种群（候选解决方案和测试案例）。这两组种群分别通过一个由其对立种群成员的交互（游戏）结果所引导的演化搜索过程来进行进化。竞争性协同进化的成功实现要求将两组协演种群进行耦合，从而在一般的协同进化周期中不断促进两种群间的军备竞赛动态。

对于通过合作性协同进化算法以分而治之方式解决优化问题，其算法设计和具体实现会更为复杂，具体执行取决于所处理的问题类型。我们的介绍集中在一类加性可分离的优化问题上，这些问题容许被分解为较小且更简单的子组件。在这种情况下，合作性协同进化算法包含多个遗传隔离的种群，其中每个种群对应某个具体子组件的候选解决方案。当每个种群进行演化过程以搜索其子组件候选解决方案时，会通过与其他种群的交互结果指导这一搜索，以形成完整的解决方案。这种合作式协同进化的主要设计原则包括选择协作者的机制，以将各子组件的候选解决方案组合成完整解决方案，同时还需为各候选解决方案分配个体适应度，用于其种群中的演化搜索过程。这对于有效的合作搜索至关重要，以确保多个种群在每个协同进化周期中性能不断提高。

我们以对结合竞争和合作搜索机制来进行问题求解的协同进化系统的简短评论结束本章。实际上，在后续章节的第二部分和第三部分中，我们将更详细地介绍我们已经进行的研究，包括开发（例如文献[29, 50]）或分析（例如文献[9, 10]）这种复杂协同进化系统。然而，将竞争性与合作性协同进化搜索结合起来的理念并不是新的。早期的研究（例如文献[22, 23]）就曾提出一种竞争-合作协同进化算法框架来解决优化问题。

所提出的框架可以被视为对现存合作性协同进化算法框架的扩展。特别地，分而治之的解决问题方法仍然通过合作协同进化搜索来实现。与设计固定的决策变量分组或更复杂的学习机制来实现问题分解不同，该竞争-合作协同进化框架的动机在于利用自然的演化过程，使得决策变量分组成为一种自动涌现的属性。
在文献[22]中，竞争-协作协进化框架被应用于解决更复杂的多目标优化问题。然而，该框架可以轻松地调整用于解决较简单的单目标优化问题。这是因为个体的适应度评估和选择通过两个独立的过程——$\text{evaluationSol}$和$\text{selectionSol}$来完成。在这两个过程中，可以调整相关机制，使帕累托排序用于解决多目标优化问题。而在单目标优化问题的设置中，这种排序简化为对个体适应度所对应的实数值进行比较和排序。不管怎样，文献[22]中的协作协进化部分优化了每个遗传隔离群体中的单个变量。

这种方式中，竞争-协作协进化框架的核心基于文献[43]提出的原始协作协进化框架，该框架将$D$维问题分解为多个一维子问题。然而，与原始框架不同的是，竞争-协作协进化框架引入了机制，使多个遗传隔离的群体可以相互竞争，以提供代表任何特定一维子组件或决策变量候选解的角色。文献[22]中用于评估竞争-协作协进化算法的基准问题涉及连续函数，这些函数以实数值输入或决策变量为基础。

在此竞争-协作协进化框架中，使用多个遗传隔离的群体，每个群体由能够提供一维决策变量候选解的成员组成，带来了两个特点。首先，任何群体内的成员在规格方面与其他群体的成员兼容，因为它们都是同一类型$\mathbb{R}$。这种类型的兼容性简化了协进化框架，使得竞争和协作的搜索机制可以适用于所有群体。其次，在这种协进化设置中，群体的遗传隔离有助于维持多样性，而非像其他协作协进化搜索设置中那样通过类型保护来维持多样性。在大多数其他现有的协作设置中，群体代表由不同类型（即不同维度，因为子组件由具有不同决策变量数量的组组成）子组件的候选解，并且需要遗传隔离以保证这种差异。在这里，带有相同类型$R \rightarrow R \, ( \mathbb{R} \rightarrow \mathbb{R})$的过程$\text{variationSol}$可以应用于任何群体，从父代生成新的子代候选解。

更重要的是，不同且各异的群体竞争以提供特定子组件的角色，这些子组件随后合并为完整解，从而引发了子组件之间的潜在相互依赖关系。
在文献[22]中，这两种机制以固定频率的周期性顺序依次应用。例如，竞争协同进化机制被激活一段固定数量的协同进化周期，然后切换到合作协同进化机制，同样是按照固定频率交替执行，直至终止。该研究采用了一种二进制编码方案，以使得可以使用交叉操作和比特翻转变异操作。文献[23]的研究同样实现了竞争-合作协同进化框架，但将候选解的基线适应过程替换为粒子群优化（PSO）。因此，这些研究再次表明，竞争-合作协同进化框架在问题解决方面具有较高的层次。这也意味着其他适合的群体基础的随机搜索算法能够用来搜索单个候选解决方案。最后，还有一些研究探讨了这些竞争-合作协同进化系统在其固有复杂性方面的表现。本文所强调的一个示例研究来自文献[31]，该研究使用了一种语言预测游戏，其解决方案表示形式为有限状态自动机（Finite State Automata，FSA）。与之前讨论的IPD（囚徒困境迭代博弈）游戏类似，这种语言预测游戏的互动或游戏机制涉及两名玩家在固定轮数中同时输出从某固定字母集抽取的符号。然而，与IPD游戏不同，这里使用了不同的收益矩阵，具体取决于参与的交互类型。在文献[31]中，考虑了两种交互类型，即合作和竞争。在合作游戏中，任意两名进行交互的代理只在每轮中输出相匹配的符号时才可获得相同的收益，否则收益为零。而在竞争游戏中，如果两名代理每轮均输出相同的符号，则会获得零收益；否则，根据具体的一对符号，其收益为1，仅归属于其中一名代理。为了实现这两种交互或游戏类型，目前代理群体被配置为一个网络，其中边的连接类型指定了交互类型。此外，选择语言预测游戏是为了能够通过生成相同游戏策略的最小等价FSA来衡量代理行为的复杂性。文献[31]的受控实验研究表明，当竞争和合作两种交互类型同时存在时，与仅存在单一交互类型的情况相比，代理在其最小FSA表示所测得的行为复杂性方面进化到了更高的水平。需要注意的是，每个代理代表当前问题的完整候选解决方案，例如学习同时参与竞争和合作游戏。此外，采用FSA的策略表示形式会随着行为复杂性的增长而变化，这种复杂性可通过代理根据对手动作生成的符号序列来体现。从这一角度来看，可以认为同时采用竞争和合作搜索的协同进化系统能够更好地解决需要高复杂度解表示的问题。
