# 第3章 协同进化的主要方法：竞争性与协作性

## 3.1 协同进化算法：引言

在第2章中，我们将协同进化系统作为一个广义的、总括性的术语，用于指称协同进化计算的各种实现方式。尽管已有大量研究将这些协同进化系统应用于如学习和优化等问题求解场景，但这些系统同样被用于其他应用环境，例如仿真。为了进一步说明这一点，可以考虑一类广泛的非合作博弈，如反复囚徒困境（IPD），该类博弈作为一个家族同时包含竞争性与协作性元素 [1, 36]。在这里，协同进化系统可以在两种一般性场景下使用：（1）用于评估博弈策略的搜索过程的性能，例如采用协同进化算法（CEA）的协同进化学习，当解的概念侧重于与其他策略分别比较时的博弈策略表现（例如，全背叛（All Defect）为占优纯策略）[9, 10]。（2）用于通过协同进化仿真研究导致特定种群行为产生的适应过程条件，当解的概念侧重于整个种群的总体表现时（例如，共同进化至互惠合作，从而同时最大化所有协同进化智能体的收益）[7]。

本章将重点关注那些针对第一种问题求解场景的协同进化系统，即涉及搜索性能优越解的场景。具体而言，我们将详细介绍这些CEAs的关键实现细节及其所采用的机制。我们的案例驱动讲解将采用两个问题求解场景——学习与优化，以更好地阐释竞争性与协作性协同进化的算法细节。需要注意的是，在讨论这两类问题求解场景时，我们将结合解空间搜索过程，分析各自协同进化方法所应对的关键问题挑战。例如，在面向双人棋类博弈的竞争性协同进化场景中，所要解决的问题在于搜索最优的博弈策略，其解的表示通常采用棋盘状态评估函数的参数化形式，如人工神经网络（ANNs）。
这些刺激-反应或反射型智能体本质上利用参数化函数产生的棋盘状态评估，执行单层（single-ply）搜索【5, 8, 17, 18】。换句话说，推理游戏过程所需的大部分复杂性——即生成恰当的移动序列——已经被抽象进了解的表示之中。这与经典人工智能中通过游戏树搜索来解决问题的方法不同，后者是在搜索树中寻找路径，从而生成双方交替落子、并最终以一方胜利为终点的所有可能合法移动序列。其他更复杂的搜索问题还包括基于知识的智能体规划问题，即面对环境时，结合问题的内部知识表示来推理或制定行动计划或动作序列【48】。近年来，越来越多的研究关注将协同进化（coevolution）应用于这些问题的可能性，其中包括进化机器人学（Evolutionary Robotics）和即时战略游戏（Real-Time Strategy games）等领域的相关工作【14, 20, 44】。接下来的内容中，我们将更详细地介绍与讨论用于问题求解的协同进化算法（Coevolutionary Algorithms, CEAs）的实现方式与机制。第3.2节将基于特定交互的生成与测试框架，阐述和构建竞争型与合作型协同进化算法的主要工作原理。我们将利用这些竞争性与合作性框架作为讨论和区分两种方法的关键节点。第3.3节将分为两个子节，重点讲述协同进化方法在问题求解中的应用。第一个小节讨论面向学习问题的竞争型协同进化，第二个小节讨论面向优化问题的合作型协同进化。本章结尾将总结并讨论如何结合竞争与合作型协同进化方法来解决具有挑战性的问题。

## 3.2 协同进化算法的框架

本节将介绍两种协同进化方法的一般框架。首先在第3.2.1节中引入竞争型协同进化算法框架，其后在第3.2.2节中引入合作型协同进化框架。这两种框架均是在第1章1.2节中讨论过的一般进化算法（EA）“生成与测试”框架（见算法1.1）的扩展。可以将这些框架视为特殊的扩展，实现了智能体之间的基本交互机制，进一步使特定的协同进化搜索成为可能。竞争型协同进化中包括对抗性（adversarial）交互，合作型协同进化中包括类似“分而治之”（Divide-and-Conquer）的策略性交互。

### 3.2.1  竞争型协同进化

竞争协同进化（competitive CEA）的一般框架如算法3.1所示。需要注意的是，在介绍该框架时，我们考虑了更为一般的情形，即协同进化过程中主体间的对抗性互动被抽象化并建模为不对称的双人博弈。这意味着两位博弈者扮演不同的角色，扮演第一玩家角色的主体可以使用与第二玩家不同的策略集合。实际上，在更加具体的对称双人博弈情形下，算法3.1可以直接重构为只使用单一群体，并在过程上表现得与算法1.1所示的进化算法（EA）框架更加相似。然而，在更一般的非对称交互背景下，假设两类玩家拥有不同的策略集合，这一特性指向了该框架本质上的其他设计特征。具体而言，可以注意到其显著特点——拥有两个在遗传上彼此隔离的种群。

在共优化（cooptimization）背景下，候选解群体表示为 $X_s=\big((\boldsymbol{x}_s, f)_i : i = 1,2,3,\ldots,n\big)$，而测试用例的群体表示为 $X_t=\big((\boldsymbol{x}_t, f)_i : i = 1,2,3,\ldots,m\big)$。需要指出的是，在协同演化计算（Coevolutionary Computation）相关文献中，还引入并使用了其他术语，其中一些是生物学启发的，包括捕食者-猎物和宿主-寄生虫协同进化等。但这些协同进化系统均可在本文所阐述与讨论的竞争协同进化框架下进行过程性描述。

算法3.1中的框架将竞争协同进化描述为发生在两个遗传隔离的种群上的过程，每个种群分别经历一个依次进行的适应过程。一般的竞争性CEA通过主程序CMCEA实现，其中明确指出，候选解种群 $X_{slocal}$ 通过EVOLPOPSOL适应进化，而测试用例种群 $X_{tlocal}$ 则通过EVOLPOPTEST进行适应进化。两组群体之间的遗传隔离至关重要，因为针对特定群体内主体施加适应性过程的机制，在两种角色间是不同的。例如，在variationSol中所调用与执行的具体变异算子会生成属于 $\mathbb{R}^D$ 型的单个子候选解 $(\boldsymbol{x}_s)_i$。variationSol过程会将这些生成的个体复制到完整种群 $X_{slocal}$ 的一个分区中，然后返回新的完整群体 $X_{slocal}$。类似地，variationTest作用于 $X_{tlocal}$，通过生成并复制属于 $\mathbb{R}^E$ 的单个子测试用例 $(\boldsymbol{x}_t)_i$。variationSol与variationTest中的变异算子至少因 $\mathbb{R}^D \neq \mathbb{R}^E$ 而在规范上存在区别。不过，两者都可以采用类似机制（例如，这种情况下1.2.3中介绍的实值变异算子族）。同样，种群间的遗传隔离性对于选择算子的需求也是可以确定的。一方面，selectionSol作为类型 $\mathcal{X} \rightarrow \mathcal{X}$ 的函数，作用于候选解群体 $X_{slocal}$，整体上……（后文未完）。
<img src="C:\Users\y50047890\AppData\Roaming\Typora\typora-user-images\image-20250605112455251.png" alt="image-20250605112455251" style="zoom:67%;" />

选择算子是类型为 $X \boldsymbol{\mathcal X}$ 的操作。该操作以一个种群配置作为输入，通过将选出的个体放在种群顶端（该部分称为父代分区）来改变其配置，并输出用于下次迭代的新种群配置 $X_{s\text{local}} = X_j \in \boldsymbol{\mathcal X}$。  

另一方面，$\text{selectionTest}$ 以相同方式作用于 $Y \boldsymbol{\mathcal Y}$。它是类型为 $Y \rightarrow Y \boldsymbol{\mathcal Y} \rightarrow \boldsymbol{\mathcal Y}$ 的函数，输入为一个种群配置，对其进行变换后，输出新的种群配置 $X_{t\text{local}} = Y_j \in \boldsymbol{\mathcal Y}$。  

前文中我们已经定义，候选解和测试用例的种群可表示为  
$( (x_s, f)_i : i = 1, 2, 3, \ldots, n )$
$\big(({\boldsymbol x}_{\mathbf{s}},f)_i : i = 1,2,3,\ldots,n\big)$ 和 $\big(({\boldsymbol x}_{\mathbf{t}},f)_i : i = 1,2,3,\ldots,m\big)$ 分别表示两个种群。由此，selectionSol 和 selectionTest 中的选择算子至少在其定义上是不同的，因为两个配置空间是不同的（即 $\boldsymbol {\mathcal X} \neq \boldsymbol {\mathcal Y}$，若 $n \neq m$），尽管可以使用相同机制的选择算子（例如，1.2.4 节描述的锦标赛选择）。我们在 EVOLPOPSOL 中使用变量名 $\boldsymbol X_{\!\mathbf{slocal}}$，在 EVOLPOPTEST 中使用变量名 $\boldsymbol X_{\!\mathbf{tlocal}}$，以强调适应性过程是局部应用于候选解和测试用例的种群，因此它们之间保持遗传隔离。然而，这两个种群通过评估种群成员适应度或性能的过程实现交互。例如，evaluationSol 会利用 $\boldsymbol X_{\!\mathbf{tlocal}}$ 对 $\boldsymbol X_{\!\mathbf{slocal}}$ 进行更新，特别是更新 $\big({\boldsymbol x}_{\mathbf{s}}, f\big)_i, \ i = 1,2,3,\ldots,n$ 中所有个体的适应度值，这些值被赋予变量名 $f$，并通过 $\boldsymbol X_{\!\mathbf{slocal}}[i].f$ 来访问。同理，evaluationTest 则利用 $\boldsymbol X_{\!\mathbf{slocal}}$ 来更新 $\boldsymbol X_{\!\mathbf{tlocal}}$ 中的适应度值。当同时考虑 EVOLPOPSOL 和 EVOLPOPTEST 都采用进化适应性过程时，可以将 CMCEA 过程性地描述为一个具有耦合适应度评估的协同进化系统。参数 $c_{\mathrm{sol}}$ 和 $c_{\mathrm{test}}$ 分别控制 EVOLPOPSOL 和 EVOLPOPTEST 中适应性过程的持续时间。这两个参数中的任意一个都决定了在相应的 EVOLPOPSOL 或 EVOLPOPTEST 过程中，在终止前对当前种群重复多少次变异和选择算子的进化循环（包括对种群成员的适应度评估）。它们分别由 EVOLPOPSOL 或 EVOLPOPTEST 中的变量 $c_s$ 和 $c_t$ 跟踪。随后，主过程 CMCEA 将调用并执行对另一种群的进化适应性过程。这些对 EVOLPOPSOL 和 EVOLPOPTEST 的反复调用和执行会持续，直到由 $s_{\mathrm{term}}$ 指定的终止准则通过 $b_{\mathrm{term}}$ 标志的变化触发主过程 CMCEA 中循环的结束，从而终止协同进化过程的计算模拟。终止准则可以是循环的固定迭代次数，也可以是其他更为复杂的方案，这些都在 termination 中被记录，并由 $s_{\mathrm{term}}$ 选择执行。需要注意的是，一个完整的协同进化周期指的是在 CMCEA 主循环中完成一次 EVOLPOPSOL 和 EVOLPOPTEST 的执行，该过程由变量 $t$ 跟踪。

3.2.2 协作式协同进化
我们提出了协作协同进化（cooperative CEA）的通用框架，该框架如算法3.2所示。在该框架中，基本假设是研究的问题属于可加性可分问题家族，即这些问题允许如下形式的分解：

$$f(\boldsymbol{x}) = \sum_{i=1}^{m} f_i(\boldsymbol{x}_i)$$

其中 $m \leq D$，且每个子组件 $\boldsymbol{x}_1, \ldots, \boldsymbol{x}_m$ 是彼此独立的。

算法3.2 协作协同进化的一般框架

输入：  
$D$: 问题的维度  
$N$: 个体种群的规模  
$f_{\text{sel}}$: 从可加性可分问题库中选择问题  
$s_{\text{term}}$: 选择的全局终止判据  
$c_{\text{sol}}$: 个体子种群进化轮次的终止判据  

输出：  
$x$: 演化得到的候选解

1: procedure COCEA($f_{\text{sel}}$, $D$, $N$, $s_{\text{term}}$, $c_{\text{sol}}$)  
2: $t := 0$  // 初始化时间标记  
3: $b_{\text{term}} := \text{true}$  // 初始化循环条件  
4: $F := \text{problemDecom}(D, f_{\text{sel}})$  // 根据问题分解初始化结构$F$  
5: $b := \text{initContext}(D, F)$  // 随机初始化上下文向量$b$  
6: $f_b := \text{evaluate}(b)$  // 令 $f_b = f(b)$  
7: for $i = 0 : F.m$ do  
8: $X_i := \text{initializeSubPop}(D, N, F, i)$  // 为$F.m$个子组件初始化子种群  
9: end for  
10: while $b_{\text{term}}$ do  
11: $b := \text{EVOLPOPSOL}(f_{\text{sel}}, D, N, X_i, F, i, b, f_b, c_{\text{sol}})$  // 演化第$i$个子组件的种群  
12: $t := t + 1$  // 协同进化周期数加一  
13: $b_{\text{term}} := \text{termination}(b, t, s_{\text{term}})$  // 判断是否终止  
14: end while  
15: $x := b$  
16: return $x$  
17: end procedure

18: procedure EVOLPOPSOL($f_{\text{sel}}$, $D$, $N$, $X_i$, $F$, $i$, $b$, $f_b$, $c_{\text{sol}}$)  
19: $cs := 0$  // 初始化进化轮次计数  
20: $c_{\text{solterm}} := \text{true}$  // 初始化循环条件  
21: $X_{s\_local} := \text{seedSol}(X_i)$  // 初始化$X_{s\_local}$父母种群  
22: while $c_{\text{solterm}}$ do  
23: $X_{s\_local} := \text{variationSol}(N, X_{s\_local}, F, i)$  // 对$X_{s\_local}$应用变异算子  
24: $\text{evaluationSol}$($f_{\text{sel}}$, $N$, $X_{s\_local}$, $F$, $i$, $b$)  // 对$X_{s\_local}$进行适应度评估  
25: $b := \text{updateContext}(D, N, X_{s\_local}, F, i, b, f_b)$  // 更新上下文向量$b$  
26: $f_b := \text{evaluate}(b)$  // 更新 $f_b = f(b)$  
27: $X_{s\_local} := \text{selectionSol}(N, X_{s\_local})$  // 对$X_{s\_local}$应用选择算子  
28: $cs := cs + 1$  // 进化轮次加一  
29: $c_{\text{solterm}} := \text{terminationSol}(X_{s\_local}, cs, c_{\text{sol}})$  // 子过程终止判据判断  
30: end while  
31: return $b$  
32: end procedure

上述分解方式意味着 $D$ 维问题的目标函数可以表达为 $m$ 个独立子组件的可加组合，其中 $m \leq D$。我们的框架与文献[30]最近一篇关于协作协同进化算法综述中的框架类似，实际上，该综述基于文献[43]提出的协作协同进化通用框架。然而，与其主要处理问题被分解为$D$个一维子问题（即$m = D$）不同，我们对框架进行了泛化，提出了一种适用于 $m \leq D$ 情形的方法。实际上，这一需求在主程序COCEA中得以明确，即它以从可加性可分问题库中选择问题 $f_{\text{sel}}$ 作为输入之一。
一般的协作式协同进化算法（Cooperative Coevolutionary Algorithm, CEA）通过主程序 COCEA 实现，该主程序在初始化后调用 problemDecom 过程，对选定的问题进行分解。后者的输出是一个数据结构 $\boldsymbol{F}$，其用于捕捉和表示问题分解的结果，即将非可分的决策变量分组成若干子分量 $\boldsymbol{x}_1, \ldots, \boldsymbol{x}_m$。这一过程通过从决策变量向量 $\boldsymbol{x} = (x_1, \ldots, x_D)$ 中提取并归纳相关的索引号，实现变量分组，并将这些索引作为各个子分量的值存储下来。令 $\mathbb{Z}_{1 \leq z \leq D} = \{1,2,3,\ldots,D\}$ 表示决策变量 $\boldsymbol{x}$ 的索引集合。数据结构 $\boldsymbol{F}$ 可描述如下：
$$
\boldsymbol{F} = (m, \boldsymbol{s}, \mathbf{IDX}),
$$
其中： 
$$
m \in \mathbb{Z}_{1 \leq z \leq D},
$$
$$
\boldsymbol{s} = (s_{i} : i = 1,\ldots,m),\ s_{i} \in \mathbb{Z}_{1 \leq z \leq D},
$$
$$
\mathbf{IDX} = (\mathbf{idx}_{i} : i = 1,\ldots,m),
$$
$$
\mathbf{idx}_{i} = (\mathrm{index}_{i,j} : j = 1,\ldots,s_{i}),\ \mathrm{index}_{i,j} \in \mathbb{Z}_{1 \leq z \leq D}。
$$
即
$$
\boldsymbol{F} = (m, \boldsymbol{s}, \mathbf{IDX}),
m \in \mathbb{Z}_{1 \leq z \leq D},
\boldsymbol{s} = (s_i : i = 1, \ldots, m), s_i \in \mathbb{Z}_{1 \leq z \leq D},
\mathbf{IDX} = (\mathbf{idx}_i : i = 1, \ldots, m),
\mathbf{idx}_i = (\mathrm{index}_{i,j} : j = 1, \ldots, s_i), \mathrm{index}_{i,j} \in \mathbb{Z}_{1 \leq z \leq D}。
$$
在式 (3.1) 中，$\boldsymbol{F}.m$ 表示问题分解后不相交子分量的个数。$\boldsymbol{F}.\boldsymbol{s}[i]$ 表示第 $i$ 个子分量 $\boldsymbol{x}_i$ 的维数，是区间 $[1, D]$ 上的正整数 $s_i$。$\boldsymbol{F}.(\mathbf{IDX}[i]) = (\mathrm{index}_{i,1},\ldots,\mathrm{index}_{i,s_i})$ 是一个维数为 $s_i$ 的向量，其各分量为属于集合 $\mathbb{Z}_{1 \leq z \leq D}$ 的不同正整数。实质上，它是一个正整数列表，每个整数表示与第 $i$ 个子分量 $\boldsymbol{x}_i$ 相关的 $\boldsymbol{x} = (x_z : z = 1,2,3,\ldots,D)$ 中的变量索引。

这种问题分解具有两个性质（或不变性）：
第一，有 $\sum_{i = 1}^m s_i = D$；
第二，联合所有 $\boldsymbol{F}.(\mathbf{IDX}[i])$ 的不同正整数，即所有 $\mathrm{index}_{i,j},\ i=1,\ldots,m,\ j=1,\ldots,s_i$，恰好构成 $1,\ldots,D$ 的一个排列。

在具体实现中，$\boldsymbol{F}$ 被所有其他过程用作子分量 $i=1,\ldots,m$ 及其对应决策变量的索引。下面以一个示例说明这种分解方式。

假设有一个加性可分的问题，其决策变量为 $\boldsymbol{x} = (x_1, x_2, x_3)$，它可以被分解为 $f({\boldsymbol x}) = \sum_{i = 1}^2 f_i({\boldsymbol x}_i)$。其中，$\boldsymbol{x}_1 = (x_2)$ 且 $\boldsymbol{x}_2 = (x_1, x_3)$（注意，这里我们以一个变量列表的形式表示向量，有别于标准记法）。过程 problemDecom 返回如下结构：
$\boldsymbol{F} = (m, \boldsymbol{s}, \mathbf{IDX})$，其中 $m = 2$，$\boldsymbol{s} = (s_1, s_2) = (1, 2)$，$\mathbf{IDX} = (\mathbf{idx}_{1}, \mathbf{idx}_{2})$，$\mathbf{idx}_{1} = (2)$，$\mathbf{idx}_{2} = (1, 3)$。$F = (m, s, IDX), m = 2, s = (s_1, s_2) = (1, 2), IDX = (idx_1, idx_2), idx_1 = (2), idx_2 = (1, 3)$。

算法3.2能够利用由$\boldsymbol{F}$所捕捉和表征的问题分解结构，进而以协作的方式解决可加分离问题的优化。这一目标通过使用上下文向量$\boldsymbol{b}$及适应过程得以实现，适应过程针对$2 \leq m \leq D$个遗传隔离的种群按顺序执行。在这种协作式协同进化算法（CEA）框架中，上下文向量$\boldsymbol{b}$承担着两个重要角色：（1）它根据针对每个第$i$个种群选择的个体，表现为当前完整解的拼接，即$\boldsymbol{b} = (\boldsymbol{b}_i : i = 1, \ldots, m)$，在所有$m$个种群经由EVOLPOPSOL进化适应过程后组装而成（即$\boldsymbol{b}_i \in \boldsymbol{X}_i.\boldsymbol{x}$）；（2）在相应第$i$个种群的进化适应过程中，$\boldsymbol{b}$为每个代表第$i$子组件的个体候选解$\boldsymbol{x}_i$的适应度或性能评估提供支撑。这是因为每个子组件的适应度函数$f_i$通常是未知的（例如在黑箱优化中）。上下文向量$\boldsymbol{b}$的第一个作用对应于evaluate过程，即通过$f(\boldsymbol{b})$计算当前完整解的适应度。

在算法3.2的开始，完整解$\boldsymbol{b}$通过initContext初始化。这一过程可以采取在$\mathbb{R}^D$中随机采样的常规方法，也可以采用更复杂的利用已知解进行播种的初始化方法。更为重要的是，上下文向量$\boldsymbol{b}$在执行第$i$个种群$\boldsymbol{X}_i$的EVOLPOPSOL进化适应过程中，通过updateContext以顺序方式对每个第$i$子组件进行更新，$i=1,\ldots,m$。

考虑一个目标函数$f(\star)$为可加分离的最小化问题，具有正确的问题分解$\boldsymbol{F}$，且已知各子组件适应度函数$f_i, \ i=1,\ldots,m$。则第$i$子组件的新选或更新可表示为
$$
\boldsymbol{b}_i = \mathop{\mathrm{argmin}}_{\boldsymbol{x}_{i,k} \in \boldsymbol{X}_i.\boldsymbol{x}} f_i(\boldsymbol{x}_{i,k}) = \mathop{\mathrm{argmin}}_{\boldsymbol{x}_{i,k} \in \boldsymbol{X}_i.\boldsymbol{x}} (f_i(\boldsymbol{x}_{i,k}) + C)
$$
在第$i$子组件更新时，$C = \sum_{j \in \{1,\ldots,m\} \backslash \{i\}} f_j(\boldsymbol{b}_j)$为一个常数，因为其它所有子组件$\{\boldsymbol{b}_1, \ldots, \boldsymbol{b}_m\} \backslash \{\boldsymbol{b}_i\}$已固定或保持上一次的选择。于是实际上有
$$
\boldsymbol{b}_i = \mathop{\mathrm{argmin}}_{\boldsymbol{x}_{i,k} \in \boldsymbol{X}_i.\boldsymbol{x}} f_i(\boldsymbol{x}_{i,k}).
$$
但实际上无法直接实现该操作，因为$f_i$是未知的。实际在updateContext中选择合适的$\boldsymbol{b}_i$需通过比较$f(\boldsymbol{x}_{i,k} \cup \boldsymbol{b}^c)$的值，其中$\boldsymbol{b}^c$指预先选定的所有其它子组件个体。$f(\boldsymbol{x}_{i,k} \cup \boldsymbol{b}^c)$的值充当代理，用以确定哪些第$i$子组件候选解$\boldsymbol{x}_{i,k}$满足$\min_{\boldsymbol{x}_{i,k} \in \boldsymbol{X}_i.\boldsymbol{x}} (f_i(\boldsymbol{x}_{i,k}) + C)$[30]。其中，$\boldsymbol{x}_{i,k} \cup \boldsymbol{b}^c$表示完整解向量。

这一通过$f(\boldsymbol{x}_{i,k} \cup \boldsymbol{b}^c)$来计算$f_i(\boldsymbol{x}_{i,k})$“适应度”的过程被称为补全（complementation）。
EVOLPOPSOL过程实现了对每个第 $i$ 个种群 $\boldsymbol{X}_i = \big((\boldsymbol{x}_{i}, f)_k : k = 1, \ldots, N\big)$ 的进化适应过程，该种群由为第 $i$ 个子组件提供的个体候选解 $\boldsymbol{x}_{i,k}$ 组成。该过程与任何进化算法（EA）中的过程相同，参数 $\mathrm{csol}$ 控制该过程或进化周期的持续时间（例如，进化算子被重复调用的次数），该进度通过变量 $c_s$ 进行跟踪。唯一的例外是，各个子组件 $\boldsymbol{x}_i$，$i=1,\ldots,m$ 的维度 $s_i$，$i=1,\ldots,m$ 可能不同，因此用于生成子代候选解的变异算子 $variationSol$ 需要问题分解结构 $\boldsymbol{F}$ 的信息。用于为下一代选择父代的选择算子 $selectionSol$ 需要种群规模 $N$ 的基本信息。该参数对所有种群均为固定值，尽管可以为每个第 $i$ 个子组件选择不同的种群规模 $N_i$。对每个候选解 $\boldsymbol{x}_{i,k}$ 的适应度评估通过 $evaluationSol$ 过程实现。该过程需要当前的上下文向量 $\boldsymbol{b}$，候选解 $\boldsymbol{x}_{i,k}$ 的适应度计算方式为 $\boldsymbol{X}_i[k].f = f(\boldsymbol{x}_{i,k} \cup \boldsymbol{b}^c)$。最后需要注意的是，EVOLPOPSOL 实现了 $updateContext$ 来选择在上下文向量中第 $i$ 个子组件的最优候选解。对于可加分离问题和正确的问题分解结构 $\boldsymbol{F}$，有
$$
\boldsymbol{b}_i = \mathop{\mathrm{argmin}}_{\boldsymbol{x}_{i,k} \in \boldsymbol{X}_i.\boldsymbol{x}}\, (f_i(\boldsymbol{x}_{i,k}) + C) = \mathop{\mathrm{argmin}}_{\boldsymbol{x}_{i,k} \in \boldsymbol{X}_i.\boldsymbol{x}}\, f_i(\boldsymbol{x}_{i,k})\,.
$$
随后，在完成了针对 $i=1,\ldots,m$ 的 EVOLPOPSOL 过程调用汇成的一个协同进化周期后，可以获得原问题的完整候选解，即
$$
\boldsymbol{b} = \Big(
\mathop{\mathrm{argmin}}_{\boldsymbol{x}_{1,k} \in \boldsymbol{X}_1.\boldsymbol{x}}f_1(\boldsymbol{x}_{1,k}),
\ldots,
\mathop{\mathrm{argmin}}_{\boldsymbol{x}_{m,k} \in \boldsymbol{X}_m.\boldsymbol{x}}f_m(\boldsymbol{x}_{m,k})
\Big)
$$
协同协作进化算法（cooperative CEA）的终止准则由 $\mathrm{s}_{\mathrm{term}}$ 指定。这可以包括一个固定的迭代次数或用变量 $t$ 跟踪的协同进化周期数，也可以是更复杂的机制，比如检测种群的（过早）收敛。关键是，最终更新后的上下文向量 $\boldsymbol{b}$ 应该是表现最优的，在算法主过程 COCEA 终止时，将该向量作为最终解返回。

## 3.3 协同进化问题求解

在第2章中，我们概述了协同进化计算的相关文献，讨论了协同进化系统在各种实际问题求解中的发展。特别地，协同进化系统重点关注并被广泛研究的两种通用设定分别是学习和优化。第2.4.2节指出，将对抗性协同进化用于学习和将协作性协同进化用于优化，都是基于这两种协同进化方法中种群交互的具体形式化。这些形式化被利用，并且被进一步发展为在第3.2节中介绍的对抗性与协作性CEA算法框架中的主要性能或适应度评估机制。在本节中，我们将更为详细地讨论这些通用协同进化算法框架如何应用于学习和优化这两类问题求解设定。我们的介绍将以实例驱动，并将展开阐述文献中提出的涉及这些CEA设计的具体问题，从而应对这些应用场景下所固有的挑战。
### 3.3.1 竞争协同进化用于学习

我们首先讨论用于博弈学习问题的单种群竞争协同进化算法（CEA），在此类问题中，种群中的任意个体都可以同时扮演候选解和测试用例的角色。事实上，仅在竞争性CEA中，这样的单种群配置才较为常见。在这里，竞争性协同进化学习为搜索博弈策略提供了一种替代方法。在这种设置下，要么已知游戏是对称的，因此博弈策略集对于双方玩家来说是相同的；要么可以假设游戏近似对称。这一假设已被应用于诸如跳棋 [5]、黑白棋 [8]、国际象棋 [18] 和围棋 [47] 等涉及两位玩家轮流行动的棋类游戏中。甚至可以进一步假设，协同进化获得的策略需要学会同时以两种颜色（即作为先手和后手）下棋，并据此制定适当的适应度评估方式，以综合考虑作为先手与后手对抗任意测试对手时的表现。

我们首先以双人对称囚徒困境（IPD）博弈的学习策略的竞争协同进化为例 [3, 6, 11, 15, 16, 19]。在该设置下，竞争性CEA与一般的进化算法（如算法1.1所述）类似，主要区别在于种群中博弈体的适应度评估是基于实际对局进行的。在为特定问题设计进化算法的流程同样适用于协同进化算法。尤其是策略或解的表示方式的设计选择会显著影响进化算子的效果，特别是对变异算子的影响。

双人IPD博弈包括两位玩家在固定回合数内同步做出一系列联合行动。在每回合中，玩家可以选择合作（C）或背叛（D）作为下一步操作。基于记忆的反应策略（memory-based reactive strategies），即利用过去自身行为、对手行为或二者联合历史来决定当前行动的策略，已经得到了充分研究。例如，开创性的研究 [3] 将协同进化学习过程限定在记忆长度为三的反应型IPD策略空间中。这样的策略可以表示成包含过去三步联合行动的查找表，总共有$(2^2)^3=64$个表项。（注意，每一回合共有$2^2=4$种可能的联合行动组合，分别为$(C,C),(C,D),(D,C),(D,D)$。）查找表中的每个表项存储着当前应采取的行动，即合作（C）或背叛（D），可表示为$p_{\mathrm{addr}}$。查找表的每个存储位置都由过去三步联合行动的信息来索引。所有地址的完整集合$\boldsymbol{A}$包含$|\{C,D\}|^{|\{1,2\}\times\{1,2,3\}|} = 2^6 = 64$个元素。每个地址$addr=(m \in \{C,D\}, i, r): i=1,2, r=1,2,3$。
$\mathrm{addr} = \big((m \in \{\mathrm{C},\mathrm{D}\},i,r) : i = 1,2, r = 1,2,3\big)$被写作一个包含六个三元组的列表，其中索引$i = 1,2$表示实施动作的玩家（1表示自己，2表示对手），索引$r = 1,2,3$表示之前的第$r$局。三轮联合动作的历史博弈涉及六步操作，$i, r$的索引在$\mathrm{addr}$中被用来指示每步操作所对应的玩家及轮次。例如，当两位玩家在前三轮均选择合作时，第一位玩家将这段历史博弈表示为$\mathrm{addr} = \big((\mathrm{C},1,1),(\mathrm{C},2,1),(\mathrm{C},1,2),(\mathrm{C},2,2),(\mathrm{C},1,3),(\mathrm{C},2,3)\big)$。随后，策略以一个映射$\mathbf{T} : \mathbf{A} \rightarrow \{\mathrm{C},\mathrm{D}\}$的形式给出，其中$\mathbf{T} = (p_{\mathrm{addr}} \in \{\mathrm{C},\mathrm{D}\} : \mathrm{addr} \in \mathbf{A})$，其输出$\mathbf{T}(\mathrm{addr}) = p_{\mathrm{addr}} \in \{\mathrm{C},\mathrm{D}\}$为对应查找表中的结果C或D。注意，在最初的三轮中，尚不存在足够的历史联合动作以便查表$\mathbf{T}$，因此，任何基于记忆的响应性策略都需要额外的机制，在完整的历史联合动作不可用时以某种方式初始化行为。在文献[3]中，这一机制通过为每个策略假定三轮初始历史来实现。如此一来，策略便可以通过处理这些假定的历史博弈，精准定位查找表的特定项，并得到输出$\mathbf{T}(\mathrm{addr})$。这也完整定义了记忆-三关联的IPD（囚徒困境）响应性策略。

该研究进一步采用了针对策略表示的遗传（二进制）编码方案。由于$\mathbf{T}$中有$(2^2)^3 = 64$个元素（表项），另外为了假设历史博弈还需要$(2 + 2 + 2) = 6$个元素，因此整个编码方案产生一个长度为70的二进制串。每一位比特关联对应一个特定元素，可人为规定0表示C、1表示D。这一遗传编码方案使得可以使用遗传算法（GA）实现该竞争性共进化算法（CEA），以搜索囚徒困境的策略。在[3]中，采用了一个包含20个个体的单一群体，变化算子包括单点交叉及以显著低概率发生的比特翻转变异；所用选择算子为基于适应度的比例选择。每个个体的适应度通过累计其在囚徒困境游戏所有对局中的博弈结果之和来评价。每个个体与群体中另外19个个体（即不进行自对弈）进行博弈。对于每场对局，某个实现特定IPD策略的个体的结果是其在与对手共进行151轮博弈后获得的累计收益。第一玩家的收益通过矩阵$\mathbf{G} = (g_{ij} : i,j = \mathrm{C},\mathrm{D})$指定，其中$i$为第一（行）玩家的动作，$j$为第二（列）玩家的动作。任意两人、两选项的IPD收益矩阵$\mathbf{G}$包括四个非负实数$(R,S,T,P) = (g_{\mathrm{C}\mathrm{C}},g_{\mathrm{C}\mathrm{D}},g_{\mathrm{D}\mathrm{C}},g_{\mathrm{D}\mathrm{D}}), \ R,S,T,P \in \mathbb{R}_{\geq 0}$。其中四个变量$R, S, T, P$有特定的博弈含义：$R$为双方均合作时的奖励，$S$为在对方背叛下独自合作的“傻瓜”收益，$T$为选择背叛时的诱惑，$P$为双方均背叛时的惩罚[2]。它们必须满足如下条件：(1) $T > R$且$P > S$（背叛收益更高），(2) $R > P$（合作优于互相背叛），(3) $R > (T+S)/2$（交替背叛不如互助）。文献[3]采用$(R, S, T, P) = (3, 0, 5, 1)$，尽管其他满足条件的参数组合也可使用。无论如何，通过对轮数和对局场次数进行合适归一化，均可确保群体中任意个体的适应度（由累计收益定义）在$[S, T]$区间内。
请注意，单种群竞争性协同进化算法（CEA）设计中所涉及的一般原则同样适用于其他具备对称策略集假设的二人博弈。论文的具体细节大多集中在博弈策略的参数化表示及其相关变异算子的设计上。尤其是，人工神经网络（ANNs）已被用于基于棋盘状态评估函数，为各种二人棋类游戏提供博弈策略的参数化表示 [5, 8, 18, 47]。在大多数研究中，设计并应用了实值型变异算子，以产生以ANNs形式表示的新博弈策略。例如，文献 [47] 针对围棋策略学习的竞争性CEA，采用了用于棋盘状态评估的加权线性函数。该函数表示为一个带有非线性双曲正切输出的单节点ANN。目前已经研究的竞争性CEA既包括精英型 $(1+\lambda)$-ES，也包括非精英型 $(1,\lambda)$-ES（即，种群中的单一父代个体总是被最优子代取代）。此外，所研究的变异算子包括两种非各向同性的变异算子，其中一种使用固定的 $\sigma_i$，另一种则对 $\sigma_i$ 进行自适应（相关细节可参考第1.2.3节）。也有采用更复杂ANN结构的方案，如文献 [5, 8, 18] 中的多层感知机（MLP）。当然，也可以设计更复杂的策略表示和变异算子的组合，用以进化表示结构（如ANN拓扑），或融合领域知识，实现用户设计的固定结构（例如文献 [18] 在国际象棋中采用了三个分别聚焦于棋盘不同区域的ANNs）。

前文我们简要讨论了，对于二人顺序棋类游戏，可以更进一步为竞争性CEA的应用提供合理性论证，让智能体能同时学习先手与后手的博弈策略。例如，文献 [47] 应用了常用的循环赛制（roundrobin tournament）选择算子，即每个智能体都要与种群中的其他智能体对弈，但排除自我对弈。此外，适应度评估会考虑两种角色：在任意一对智能体之间，会分别让双方轮流担任先手和后手角色，各进行一组对局。游戏结果定义为 $(\mathrm{win},\mathrm{lose},\mathrm{draw}) = (1, -2, 0)$，即与传统零和设定不同，输棋的智能体要受到双倍于胜方的惩罚。在竞争性协同进化学习场景中，如此人为的指定并不罕见 [5]。然而，仍然存在其他游戏（例如Nim与三维井字棋），其中先手与后手角色明显不同。对于这类游戏，先手自带内在优势，比如通过最优策略实现必胜（Nim），或利用游戏设计中的结构性先手优势（三维井字棋），这说明先手与后手的策略集合存在本质差异。

因此，可以采用双种群竞争性CEA，对先手策略进行协同进化学习。在这种设定下，后手智能体种群充当测试策略的角色。文献 [46] 通过捕食-猎物对抗模型，验证了双种群竞争性CEA算法的有效性，并与随机生成的固定样本后手智能体对比。在该研究中，竞争性CEA集成了如适应度共享等高级协同进化设计特性，以鼓励先手、后手两个种群在基因隔离的情况下产生持续的“军备竞赛”动态。
在竞争性学习的背景下，这种动态指的是协同进化在进化历程中为（第一玩家）代理体提供了一系列有启发意义的测试策略，使其能够学习如何竞争并取胜。这与使用一组固定的随机测试策略进行系统进化学习的做法形成了对比。研究[46]指出，对于更为复杂的Nim游戏，固定样本的测试策略对于进化学习系统而言，类似于一种缺乏梯度、表现为“大海捞针”式的粗糙适应度景观。在固定样本中，击败其他剩余测试策略所包含的信息不足，进化学习很难发现能够克服那些少数难度较大测试策略的第一玩家策略。相反，协同进化学习能够搜索到随机采样时无法获得的必要中间测试策略，前提是系统配备了用于区分并在外部档案中维护新颖独特测试策略的附加机制。

### 3.3.2 优化的协作协同进化

协作协同进化通过分而治之的问题求解方法解决优化问题，该方法结合了问题分解和多种群的协同进化搜索。这要求优化问题能够被分解为更简单的问题子组件，每个子组件由一个特定、基因隔离且独立进化的候选解种群单独针对。与系统性地为各个独立子组件分别搜索最优解不同，这些种群之间通过协作搜索相互作用，从而在每轮迭代后，子组件的候选解能够同步提升其性能。这也意味着，协作协同进化算法（cooperative CEAs）涉及如3.2节算法框架所述的多个进化种群。这里假设了理想情形，即存在一种能够将加性可分优化问题正确分解的精确过程，特别是该过程输出的子组件能将相互作用的变量正确地分组在一起。如果过程$problemDecom$无法将优化问题分解成更简单的子组件，而是返回原始问题，那么协作协同进化算法将丧失其独特的搜索特性，并退化为单种群进化算法（EA）。
然而，在实际应用此类协同进化算法（cooperative CEAs）时，即使面对可加分解的优化问题，研究者往往对问题结构缺乏先验知识（即这些问题属于黑箱优化问题）。在这种情况下，如果协同进化算法的分解方式不正确，算法可能会陷入伪极小值，这主要是由于子组件间的交互作用以及相关种群进化顺序的结合导致的，从而使协同搜索偏向这些伪极小值。最近的综述文献[30]在补充材料中通过一个简单的例子说明了协同进化算法中如何产生并搜索到这样的伪极小值。此外，文献[12]中关于适应度景观的内容也讨论了类似情况——在某个连续优化问题中，特定的二进制编码方案结合单比特翻转变异可能导致局部极小值的产生。在上述两种问题情形下，合适的做法是采用能够将这些交互变量作为一个整体的表示方式，并设计能够对其作为一个整体进行变异的变化算子。其他问题情形则涉及到决策变量之间更复杂和高阶的交互关系（例如超越成对依赖性的相互作用），这些都存在于高维优化问题之中，使得问题分解变得极具挑战性[32, 40, 55]。因此，大量研究致力于开发能够有效地将交互变量分组到各自子组件中的策略，作为问题分解方法的替代。这对于黑箱可加可分优化问题中协同进化搜索的有效性和效率至关重要。因此，本节针对协同进化算法在实际应用中的问题主要聚焦于问题分解的相关内容。这些变量分组策略包括静态分组、随机分组、基于关联学习的分组、基于重叠及分层的分组，以及基于领域知识的分组机制[30]。我们将重点讨论前三类分组策略，这些方法在实现机制的复杂性上逐步递进，以展现它们在协同进化算法实施中的关键问题与挑战。我们首先从简单的静态变量分组策略开始。该类别中的各种机制并不采用任何系统化或学习过程去发现优化问题的潜在分解结构，而是通过固定和任意地将决策变量分配到各分组，以形成不同的子组件。文献[42]首次提出了简单的静态变量分组方法，将$D$维优化问题分解为$D$个一维子组件，每个子组件对应原问题的一个独立决策变量。该研究所开发的协同进化算法可由算法$3.2$描述，采用$D$个共同进化的种群。遗传算法（GA）被用于EVOLPOPSOL过程，由此形成的协同进化遗传算法（Cooperative Coevolutionary GA）在优化完全可分基准问题上，比基本遗传算法表现更优。但在决策变量间存在依赖关系的问题上，其表现不如前者。然而，通过采用更复杂的协同搜索机制，尽管计算开销增加，该方法在性能上依然优于基本遗传算法。
其他静态变量分组策略也已经被提出。例如，文献[52]提出了一种通用机制，可将$D$维优化问题静态分解为$m$个子组件，每个子组件包含$s$个不同的决策变量，并满足$D = m \times s$。虽然在静态分解时可以采用多种$m$个规模为$s$的子组件组合方式，但其有效性取决于原始问题中决策变量之间的依赖程度。更重要的是，该研究采用了粒子群优化（PSO）算法，将其用于EVOLPOPSOL过程，从而构建了合作共进化粒子群优化（cooperative coevolutionary PSO）。开创性工作[42]则采用了遗传算法（GA），而[28]中则使用了进化规划（EP）来实现EVOLPOPSOL，以对各自子组件的候选解种群进行演化搜索。这表明，合作共进化算法（Cooperative CEA）通过其算法3.2形式的框架，体现了一种更高级别的问题求解方法。因此，只要给定参数化的表示形式并经过适当准备，任何进化算法（EA）都可以用于子组件解的搜索。几乎与之独立，各种变量分组策略都可以被设计并评估其在合作共进化搜索中的有效性。下一类机制设计更为复杂的策略是随机变量分组策略。在该策略下，机制的设计重点在于解决前一类方法所面临的两个相关问题。具体而言，在共进化周期内，决策变量的分组在子组件组成及每个子组件规模方面均为固定。随机变量分组策略的机制设计总体思想，是将分解过程“移动”为共进化搜索周期的组成部分。在算法3.2的背景下，这意味着需要将过程$\texttt{problemDecom}$以及其他相关操作（如对各子组件种群的初始化或播种）移至主过程$\texttt{COCEA}$的主循环，并相应地修改用于候选解演化搜索的$\texttt{EVOLPOPSOL}$过程（如在算法3.2框架中涉及向该过程传递相关参数）。针对随机变量分组策略，已有一种较为直接的机制被提出，即将原始问题分解为$m$个规模为$s$的子组件。在[25, 53]中，问题分解在每个共进化周期开始时进行，而子组件的数量$m$及其规模$s$在整个共进化周期内保持不变。但是，每次从原始问题表示的决策变量$\boldsymbol{x} = (x_1,\ldots,x_D)$中随机选择$s$个不同决策变量，并将其分配给各自的子组件$\boldsymbol{x}_1,\ldots,\boldsymbol{x}_m$。在具体操作上，可以简单地对序列$x_1,\ldots,x_D$进行置换，然后每$s$个决策变量从左至右分组生成$m$个子组件。任意决策变量$x_i$被分配到某子组件$\boldsymbol{x}_k$的概率是均匀的。关键在于，文献[54]通过组合数学的分析，提供了在多个共进化周期内，高概率会将一组决策变量共同选入同一子组件的例子。这意味着，采用此类随机变量分组策略的合作共进化算法会在足够多的周期中对相互依赖的决策变量进行协同进化。进一步的拓展研究包括允许子组件规模在共进化周期内变化。在[26]中，提出了一种系统化的方法：如果当前规模$s^*$下无法获得可量化的适应度提升，则以均匀概率从集合$\{i \in \mathbb{Z}_{> 0} : D \mod s = 0 : s\} \setminus \{s^*\}$中选择一个新的规模$s$。另一项[51]提出的例子采用自适应方法，在共进化周期内同时调整子组件规模$s_i$及其关联种群规模$N_i$。配置的选择包括一个比较阶段，该阶段对不同的配置$(s_i,N_i),\ i = 1,\ldots,q$进行贪心搜索，以确定能够带来最佳适应度提升的配置$(s_j,N_j)$。
变量分组策略的下一个类别涉及检测问题结构中变量之间相互作用的过程，以确定优化问题能否被分解，以及在何处进行分解。这是一个活跃的研究与开发领域，综述性研究[30]将这些策略称为相互作用学习，并进一步列举了五个子类别。我们在此列举如下，并附带部分相关文献：扰动法[34, 35, 55]、统计模型[37, 45]、分布模型（如EDA）[32, 33]、近似模型[27]和关联自适应[49]。在这里，我们将简要讨论基于扰动的机制，以更好地突出在可加可分优化问题中变量相互作用的问题。我们将从这些问题中可能存在的两两变量相互作用入手，尽管相关机制已经被改进以处理高阶相互作用[55]。通过对决策变量引入特定扰动，可以揭示这些相互作用。设$f(\boldsymbol{x})=f(x_1, x_2, x_3, \ldots, x_D)$为$D$维可加可分优化问题的目标函数或适应度函数。设正整数$i,j \in \{1,2,3,\ldots,D\}$且$i<j$。对决策变量$x_i$及区间$\delta>0$，$f$关于$x_i$的前向差分$\varDelta_{\delta,x_i}f(\boldsymbol{x})$定义为:
$$
\varDelta_{\delta,x_i}f(\boldsymbol{x}) = f(\ldots, x_i + \delta, \ldots) - f(\ldots, x_i, \ldots)
$$
注意，这里仅对明示写出的决策变量$x_i$进行变化，差分式左侧的$f(*)$中的$x_i$替换为$x_i+\delta$，右侧为$x_i$。水平方省略号“$\ldots$”表示其它所有决策变量均保持不变。此外，将取值$x_i=a$、$x_j=b$代入后，前向差分写作$\varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b}$ 。已有研究[38]针对连续型可加可分优化问题$f$建立了理论结果（即对任意$x_i$存在偏导$\partial f/\partial x_i$）。具体来说，证明了如下非可分条件：对于任意决策变量对$x_i$与$x_j$，若对于所有实数$a, b_1 \neq b_2, \delta > 0$，总有
$$
\varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_1} \neq \varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_2}
$$


则该对变量$x_i$与$x_j$不可分。实际证明是成立的逆命题，这在实际中更加有用，因为它意味着当通过扰动$\delta$作用在$x_i$上计算得到的$\varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_1}$与$\varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_2}$在$x_j$取不同值$b_1, b_2$时结果相近，则$x_i$与$x_j$之间没有相互作用（即该变量对为可分的）。基于这种思想，可以通过检测两两变量相互作用来设计基于扰动的分组机制。其中包括差分分组（DG）[38]和非线性检查关联识别（LINC）[35]机制。例如，可以设置参数$\epsilon>0$，若
$$
\varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_1}
$$
与
$$
\varDelta_{\delta,x_i}f(\boldsymbol{x})|_{x_i = a, x_j = b_2}
$$
之差小于$\epsilon$，则判断$x_i, x_j$之间无显著相互作用。
我们将在本节最后简要讨论协作协同进化算法（Cooperative CEA）框架中的协作伙伴选择策略。在该框架下，有两个方面决定了其他子组件所代表的种群中候选解的协作至关重要。首先，是如何为每个子组件选择候选解，以便组合成完整解的问题。其次，是对某个子组件候选解适应度评估的依据，即这些评估基于为其他子组件已选定的候选解。针对协作伙伴选择策略，已提出了多种机制，综述性研究[30]指出了区分这些机制的两个主要因素：（i）协作伙伴选择压力，该压力与从某个子组件种群中选择候选解以组合成完整解时的“贪婪”程度相关；（ii）协作伙伴选择规模，即用于评估某个子组件种群中候选解适应度的完整解个数。

我们重点介绍三种相关机制，即最佳、随机和精英协作伙伴选择。第一种机制——最佳协作伙伴选择策略[38, 42]已经在算法3.2中给出，其采用贪婪方法来评估每个子组件的候选解适应度，并选择其中一个作为代表子组件解用于组成完整解。需注意，对于加性可分的优化问题并且已正确分解时，组合完整解的协作伙伴选择和子组件候选解适应度评估两方面能够同时得到解决。而当问题分解不当且子组件之间存在相互依赖时，最佳协作伙伴选择策略的贪婪特性则变得不合适。此时，可采用随机协作伙伴选择策略[13, 39]作为替代方案，其机制为从每个子组件相应种群中随机选取一个候选解，以构成完整解。对于精英协作伙伴选择策略[21]，该机制会从每个种群大小为$N$的协作伙伴池中，选取$K$个候选解，然后从池中随机选取候选解以组成完整解。参数$K$调节从每个种群中选择候选解时的贪婪程度，其取值范围为$[1, N]$。当$K=1$时，策略行为等同于最佳协作伙伴选择策略，即贪婪程度达到最大，每次都选择种群中的最优候选解。当$K=N$时，策略就与随机协作伙伴选择策略的行为一致。
## 3.4 结论性评述及进一步阅读建议

我们提供了两种针对优越性能解搜索的协同进化（co-evolutionary）原理的算法表达，并详细讨论了其在某些问题示例中的具体实现。第一种是用于学习环境下问题求解的竞争性协同进化算法（competitive CEA）框架。第二种是用于优化问题求解的协作性协同进化算法（cooperative CEA）框架。

对于学习问题中的竞争性协同进化算法，个体间的交互形式表现为一个双人博弈，其中候选解和测试用例分别担任第一玩家和第二玩家的角色。主导竞争性协同进化算法设计的关键原理，是基于两组遗传上隔离的人群（候选解与测试用例），它们分别经历各自的进化搜索过程，并由与对方成员的交互（即博弈）结果引导搜索。成功的竞争性协同进化实现将两个种群耦合起来，以促进两者之间的军备竞赛动态，并在连续的协同进化周期中不断循环。

针对以分而治之（Divide-and-Conquer）方式解决优化问题的协作性协同进化算法，无论在算法设计还是实际实现上，相较于竞争性算法都更加复杂。我们的讲解重点关注了可分解为较小、更简单子组件的可加分离（additively separable）优化问题。在这种情形下，协作性协同进化算法包含多个遗传上隔离的人群，每个人群对应于某个特定子组件的候选解。协同进化的发生体现在，每个人群经历进化过程以搜索各自子组件的候选解，其搜索过程受到来自其他人群成员交互结果的引导，从而组装成完整解。

具体来说，主导协作性协同进化算法设计的关键原理，包括合作者选择机制——用以组合各子组件的候选解形成完整解，以及对应各候选解个体的适应度赋值机制，以支持各自人群内部的进化搜索。这一点对于协同搜索的成功至关重要，因为多个人群必须在每轮进化周期中不断提升自身性能。

本章最后简要评论了在问题求解中结合竞争性与协作性搜索的协同进化系统。实际上，本书第二部分和第三部分后续章节将更详细地介绍我们在此类复杂协同进化系统上的开发[29, 50]或分析[9, 10]工作。然而，将竞争性和协作性协同进化搜索相结合的思想并不新鲜。早期已有相关研究[22, 23]，提出了竞争-协作型协同进化算法（competitive-cooperative CEA）用于优化问题求解。

该框架可视为现有协作性协同进化算法的扩展。具体而言，分而治之的问题求解方式依然通过协作性协同进化搜索来实现。所不同的是，不再需要设计固定的或更为复杂的学习机制（用于实现问题分解所需的决策变量分组），提出的竞争-协作型框架旨在利用自然演化过程，使决策变量的分组成为一种涌现性质而自发产生。
在[22]中，竞争-协作共进化框架已被应用于解决更为复杂的多目标优化问题。然而，该框架同样可以被轻松地调整用于求解更为简单的单目标优化问题。这是因为个体的适应度评估和选择是通过独立的过程 evaluationSol 和 selectionSol 实现的。这两个过程中的相关机制可以更改，使帕累托等级（Pareto ranks）被用于多目标优化问题的求解。在单目标优化问题设定下，排序仅仅简化为对与个体适应度相关的实值数进行比较和排序。无论哪种情况，[22]中的协作共进化方面都是针对每个基因隔离种群优化一个单一变量。以此方式，竞争-协作共进化框架的核心基于[43]提出的原始协作共进化框架，将$D$维问题分解为一维子问题。然而，该框架并未为每个特定子组件分配一个固定种群来代表候选解，而是引入了不同且多个基因隔离种群竞合，以为任何特定一维子组件或决策变量提供候选解。[22]研究中用于评估竞争-协作共进化算法的基准问题涉及连续函数，其输入或决策变量为实值。在该竞争-协作共进化框架中，使用多个基因隔离种群，每个种群的成员均可代表一维决策变量的候选解，这带来了两个特征。首先，任何一个种群内的成员在类型上与其他种群的成员兼容，因为它们均属于同一类型$\mathbb{R}$。这种类型兼容性简化了共进化框架，使得竞争和协作搜索机制能够应用于所有种群。其次，在该共进化设定中，种群之间的基因隔离有助于维持多样性，而不是像其他协作共进化搜索设定中那样仅用于类型保护。在大多数其他协作设定中，种群代表不同类型（即不同维度，因为子组件包含具有不同决策变量数量的组）的子组件的候选解，因此需要基因隔离。而在这里，类型为$\mathbb{R} \rightarrow \mathbb{R}$的variationSol过程可以应用于任一种群，从父代生成新的子代候选解。至关重要的是，不同的种群竞合以代表具体子组件的角色，这些子组件最终组合成完整解，从而引发子组件之间的涌现性依赖关系。
在文献[22]中，这两种机制以固定的周期顺序依次应用。例如，竞争协同进化被激活若干个固定的协同进化周期，随后进行同等频率的合作协同进化，如此循环往复，直到终止。该研究采用了二进制编码方案，因此可以使用交叉算子和比特翻转变异算子。文献[23]中的研究实现了同样的竞争-合作协同进化框架，但将候选解的基线适应性过程更改为粒子群优化（PSO）方法。因此，这些研究再次证明了竞争-合作协同进化框架在更高层次上的问题求解能力。这表明可以使用其他合适的基于种群的随机搜索算法来搜索个体候选解。最后，还有一些研究探讨了这些竞争-合作协同进化系统在其内在复杂性方面的表现。我们在此强调的一个实例性研究来自文献[31]，该研究采用了一种基于有限状态自动机（Finite State Automata, FSA）进行解表达的语言预测博弈。与我们之前讨论过的IPD（囚徒困境博弈）类似，该语言预测博弈的博弈过程涉及两名玩家，在固定轮次数下同时输出从固定字母集抽取的符号。但与IPD博弈不同的是，根据所涉及的成对交互类型，使用不同的收益矩阵。在文献[31]中，考虑了两种交互类型，即合作和竞争。在合作博弈中，任何两名交互的智能体若每一轮输出的符号匹配，则双方获得相同的收益，否则收益为$0$。而在竞争博弈中，如每轮输出的符号相同，则双方获得$0$收益；否则，根据所出符号的具体组合，仅其中一方获得$1$的收益。为了实现这两种交互类型，当前的智能体种群被构建为一个网络，边的类型决定了交互类型。此外，选择语言预测博弈，是因为可以通过生成同样博弈策略的最小等价FSA来度量智能体行为的复杂度。文献[31]中的受控实验表明，当竞争与合作两种交互并存时，与仅存在一种交互类型的情况相比，智能体的协同进化所表现出的行为复杂性更高（以其最小FSA表示衡量）。需要注意的是，每个智能体代表问题的完整候选解，例如需要同时学习竞争与合作博弈的玩法。此外，FSA作为博弈策略表示，其行为复杂度可以随着对对手行为响应而生成的符号序列变得更为复杂。从这个角度看，可以认为同时采用竞争与合作搜索机制的协同进化系统，更有能力解决那些对解的表示复杂度要求较高的问题。
